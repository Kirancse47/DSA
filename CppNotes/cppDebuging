#1.
class A {
public:
    A(){}
    virtual void fun(){  // virtual for runtime polymorphism
        cout<<"Kiran";
    }

    void fun2(){   // non-virtual
        cout<<"fun2 A";
    }
};

class B: public A {
public:
    B(){}
    void fun(){    // overrides A::fun
        cout<<"Pine Labs";
    }
    void fun2(){   // hides A::fun2 (not virtual)
        cout<<"fun2 B";
    }
};

int main(){
    A *p = new B();
    p->fun();   // prints "Pine Labs" (dynamic dispatch, because fun is virtual)
    p->fun2();  // prints "fun2 A" (static dispatch, because fun2 is not virtual)
}
✅ Explanation:

fun() is virtual → resolved at runtime, uses B's version.

fun2() is non-virtual → resolved at compile-time, uses A's version.

#2.

struct A {
    virtual void f(int) { cout << "A::f(int)\n"; }
};

struct B : A {
    using A::f;  // ✅ Make base class overloads visible
    void f(double) { cout << "B::f(double)\n"; }
};

int main() {
    B b;
    b.f(5);      // calls A::f(int)
    b.f(3.14);   // calls B::f(double)
}

#3.
void print(const int& x) {
    int& y = const_cast<int&>(x); 
    y = 10; 
    cout << x << endl;
}
 
int main() {
    const int a = 5;
    print(a);
}
❌ This is undefined behavior.

You are trying to modify a const int (a) via const_cast.

Modifying an object that was declared const is UB in C++.

👉 If a were non-const (e.g. int a=5;), then const_cast would be safe.

#4.
class MyString {
    char* str;
public:
    MyString(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }
    ~MyString() {
        delete str;  // ❌ should be delete[]
    }

    MyString MyString(const MyString &s){  // ❌ wrong declaration
        MyString temp;
        temp.str = new char[strlen(s.str)+1]; // also ❌ s is object, not pointer
        strcpy(temp.str, s.str);
        return temp; // ❌ copy ctor should not return
    }
};
🚩 Problems:

Destructor uses delete instead of delete[].

Copy constructor is written as MyString MyString(...) → this declares a function named MyString returning MyString, not a constructor.

Copy constructor should not return anything.

You used strlen(s) instead of strlen(s.str).

✅ Correct version:

cpp
Copy code
MyString(const MyString& s) {
    str = new char[strlen(s.str) + 1];
    strcpy(str, s.str);
}

#5.
int* foo() {
    int* p = new int(42);
    return p;   // valid
}
int main() {
    int* x = foo();
    cout << *x << endl;  // prints 42
    delete x;            // cleanup
}
✅ This is fine:

foo returns a pointer to heap memory.

The caller owns it and must delete it.

You correctly dereference it with *x.

6. Wrong Destructor (Memory Leak / Double Free)
class A {
    int* arr;
public:
    A(int n) {
        arr = new int[n];
    }
    ~A() {
        delete arr;   // ❌ Bug: should be delete[]
    }
};


Question: What is wrong here?
Expected Answer:

Using delete for an array is undefined behavior.

Should use delete[] arr;.

🔹 7. Copy Constructor Shallow Copy Bug
class MyString {
    char* str;
public:
    MyString(const char* s) {
        str = new char[strlen(s)+1];
        strcpy(str, s);
    }
    ~MyString() { delete[] str; }
};
 
int main() {
    MyString s1("Hello");
    MyString s2 = s1;  // ❌ Bug: shallow copy (default copy ctor)
}


Question: Why is this wrong?
Expected Answer:

Default copy constructor copies only the pointer, not the buffer.

Destructor runs twice → double free.

Need to implement a deep copy constructor.

🔹 8. Const-Cast UB
void f(const int& x) {
    int& y = const_cast<int&>(x);
    y = 20;   // ❌ Bug
}
int main() {
    const int a = 10;
    f(a);
}


Answer:

Modifying a const object via const_cast → undefined behavior.

Only safe if the original object is non-const.

🔹 9. Virtual Destructor Missing
class Base {
public:
    ~Base() { cout << "Base dtor\n"; }
};
class Derived : public Base {
public:
    ~Derived() { cout << "Derived dtor\n"; }
};

int main() {
    Base* b = new Derived();
    delete b;   // ❌ Bug: only Base dtor called
}


Answer:

Base destructor should be virtual to ensure proper cleanup.

Otherwise, deleting through base pointer leaks Derived resources.

🔹 10. Undefined Behavior with delete
int main() {
    int* p = new int[5];
    delete (p+1);   // ❌ Bug
}


Answer:

Only the pointer returned by new should be passed to delete.

p+1 is not valid → undefined behavior.

🔹 11. Slicing Bug
class A {
public:
    int x = 10;
    virtual void show() { cout << "A"; }
};
class B : public A {
public:
    int y = 20;
    void show() override { cout << "B"; }
};

int main() {
    B b;
    A a = b;   // ❌ Bug: object slicing
    a.show();  // prints "A"
}


Answer:

Copying derived into base object slices off the derived part.

If you want polymorphism, use references/pointers (A& a = b;).

🔹 12. Wrong Return from Function
int& foo() {
    int x = 5;
    return x;   // ❌ Bug: returning reference to local variable
}


Answer:

Local variable goes out of scope. Returning reference → dangling reference → UB.

Should return by value.


🔹 1. Rule of 3/5 Violation (Copy vs Destructor Bug)
class Buffer {
    int* data;
    size_t size;
public:
    Buffer(size_t n) : size(n) {
        data = new int[n];
    }
    ~Buffer() { delete[] data; }
};

int main() {
    Buffer b1(10);
    Buffer b2 = b1;  // ❌ Problem
}


Bug:

Compiler generates default copy constructor & assignment operator → shallow copy.

Both b1 and b2 point to same memory → double free on destruction.

Fix: Implement Rule of 3 (copy ctor, assignment operator, destructor).

🔹 2. Multiple Inheritance Diamond Destructor Bug
struct A { 
    A() { cout << "A\n"; } 
    ~A() { cout << "~A\n"; } 
};
struct B : public A { 
    ~B() { cout << "~B\n"; } 
};
struct C : public A { 
    ~C() { cout << "~C\n"; } 
};
struct D : public B, public C { 
    ~D() { cout << "~D\n"; } 
};

int main() {
    D d;   // ❌ Problem
}


Bug:

A gets constructed twice (once via B, once via C).

Multiple destruction → can cause leaks if A had resources.

Fix: Make A a virtual base class.

🔹 3. Thread Race with Static Local
void f() {
    static int counter = 0;
    counter++;
    cout << counter << endl;
}

int main() {
    std::thread t1(f);
    std::thread t2(f);
    t1.join(); t2.join();
}


Bug:

static local variable is shared between threads, increment is a race condition.

Undefined behavior without synchronization.

Fix: Protect with std::mutex or use std::atomic<int>.

🔹 4. Misuse of std::move
string getString() {
    string s = "hello";
    return std::move(s);   // ❌ Problem
}


Bug:

return std::move(s) prevents RVO (return value optimization).

s becomes moved-from before return, leading to pessimization.

Fix: Just return s; (compiler optimizes).

🔹 5. Wrong Delete with Polymorphism
struct Base {
    virtual void f() {}
    ~Base() { cout << "~Base\n"; }
};
struct Derived : Base {
    ~Derived() { cout << "~Derived\n"; }
};

int main() {
    Base* b = new Derived();
    delete b;   // ❌ Problem
}


Bug:

Base destructor is non-virtual → only ~Base() runs.

Derived part leaks.

Fix: Make Base::~Base() virtual.

🔹 6. ODR Violation (One Definition Rule)

File1.cpp

inline int foo() {
    static int x = 0;
    return ++x;
}


File2.cpp

inline int foo() {
    static int y = 100;   // ❌ different definition
    return ++y;
}


Bug:

Both files provide different definitions of the same inline function.

ODR violation → UB at link/run time.

🔹 7. Deadlock Due to Lock Ordering
std::mutex m1, m2;

void f1() {
    std::lock_guard<std::mutex> l1(m1);
    std::lock_guard<std::mutex> l2(m2);
}
void f2() {
    std::lock_guard<std::mutex> l2(m2);
    std::lock_guard<std::mutex> l1(m1);  // ❌ Problem
}

int main() {
    std::thread t1(f1);
    std::thread t2(f2);
    t1.join(); t2.join();
}


Bug:

Different lock order in f1 and f2 → potential deadlock.

Fix: Use std::scoped_lock(m1, m2) for consistent ordering.

🔹 8. Lifetime Bug with Returning Reference
const string& foo() {
    return string("Hello");  // ❌ returns reference to temporary
}


Bug:

Returning reference to a temporary → dangling reference.

Fix: Return by value (string foo()).

🔹 9. Hidden Base Function
struct A {
    virtual void f(int) { cout << "A::f(int)\n"; }
};
struct B : A {
    void f(double) { cout << "B::f(double)\n"; }  // ❌ hides A::f(int)
};

int main() {
    B b;
    b.f(5);  // calls f(double), not f(int)
}


Bug:

A::f(int) is hidden, not overridden.

b.f(5) calls f(double) instead of f(int).

Fix: Add using A::f; inside B.


#10.
struct A {
    int x;
    A(int v) : x(v) {}
};

struct B : virtual public A {
    B() : A(10) {}  // ❌ compile error
};
struct C : virtual public A {
    C() : A(20) {}  // ❌ compile error
};
struct D : public B, public C {
    D() : A(30), B(), C() {}  // ✅ Only the most derived (D) constructs A
};
🔹 The Issue
When you use virtual inheritance, the most-derived class (here D) is responsible for constructing the virtual base (A).

That means:

B and C must not call A’s constructor.

Only D can (and must) call A’s constructor.

But in your code:

cpp
Copy code
struct B : virtual public A {
    B() : A(10) {}   // ❌ ERROR
};
and

cpp
Copy code
struct C : virtual public A {
    C() : A(20) {}   // ❌ ERROR
};
Both try to initialize A, which is illegal with virtual inheritance.

The compiler complains because only D (the most-derived) can decide what value of A::x to pass.

🔹 The Fix
Remove the A(...) calls from B and C. Let D handle it:

cpp
Copy code
struct A {
    int x;
    A(int v) : x(v) {}
};

struct B : virtual public A {
    B() {}  // ✅ Don't touch A here
};
struct C : virtual public A {
    C() {}  // ✅ Don't touch A here
};
struct D : public B, public C {
    D() : A(30), B(), C() {}  // ✅ D constructs A
};
Now:

cpp
Copy code
int main() {
    D d;
    cout << d.x << endl;  // prints 30
}
🔹 Summary
In virtual inheritance, only the most derived class initializes the virtual base.

B and C cannot call A(...) — they must leave it for D.


#11.

struct A {
    void hello() { cout << "Hello from A\n"; }
};

struct B : public A { };
struct C : public A { };
struct D : public B, public C { };  // Diamond

int main() {
    D d;
    d.hello();  // ❌ ERROR: ambiguous
}
==> need to inherite virtually.


🔹 Q1. Dangling pointer
int* foo() {
    int x = 42;
    return &x;  // ❌ returning address of local variable
}
int main() {
    int* p = foo();
    cout << *p << endl;  // UB: dangling pointer
}


Issue:
x is a local variable → destroyed when foo returns. Returning &x leaves a dangling pointer. Dereferencing it is undefined behavior (UB).

Solution:
Return a dynamically allocated pointer (caller responsible to free), or better use std::unique_ptr or return by value.

int* foo() {
    return new int(42);   // caller must delete
}


OR (better):

int foo() {
    return 42;   // return by value, safe
}

🔹 Q2. Wrong delete
int* arr = new int[5];
arr[0] = 10;
delete arr;   // ❌ wrong


Issue:
You allocated with new[] but deallocated with delete. Mismatch → UB.

Solution:
Always pair correctly:

delete[] arr;

🔹 Q3. Double free
int* p = new int(5);
int* q = p;
delete p;
delete q;   // ❌ double delete UB


Issue:
Both p and q point to the same memory. Deleting twice is UB.

Solution:

Only delete once, then nullify:

delete p;
p = nullptr;
q = nullptr;


Better: Use std::unique_ptr → prevents double delete automatically.

🔹 Q4. Const pointer casting
const int a = 5;
const int* p = &a;
int* q = const_cast<int*>(p);
*q = 10;   // ❌ UB


Issue:
Casting away const on an object originally declared const and modifying → undefined behavior.

Solution:
Only use const_cast if the object was originally non-const but passed as const (e.g., legacy API). Example:

void print(int* p) {
    *p = 20;  // valid
}
int x = 5;
const int* p = &x;
print(const_cast<int*>(p));  // ✅ safe

🔹 Q5. Virtual pointer calls
struct A { virtual void f() { cout << "A\n"; } };
struct B : A { void f() override { cout << "B\n"; } };

int main() {
    A* p = new B();
    delete p;   // ❌ issue
}


Issue:
A has a virtual function but no virtual destructor. Deleting via base pointer → UB because only A’s destructor is called, not B’s.

Solution:
Make destructor virtual:

struct A {
    virtual ~A() {}     // ✅ ensures correct destructor call
    virtual void f() { cout << "A\n"; }
};

🔹 Q6. Function pointers
void fun(int x) { cout << "x=" << x << endl; }

int main() {
    void (*fp)(double) = fun;  // ❌ wrong type
    fp(3.14);
}


Issue:
Function pointer type mismatch. fun(int) cannot be assigned to void(*)(double). Some compilers may warn, but if forced → UB.

Solution:
Use correct signature:

void (*fp)(int) = fun;
fp(42);

🔹 Q7. Shared_ptr trap
struct Node {
    shared_ptr<Node> next;
};

int main() {
    auto a = make_shared<Node>();
    auto b = make_shared<Node>();
    a->next = b;
    b->next = a;   // ❌ cycle
}


Issue:
Cycle of shared_ptr → reference count never drops to 0 → memory leak.

Solution:
Break the cycle using std::weak_ptr:

struct Node {
    weak_ptr<Node> next;   // ✅ weak_ptr breaks cycle
};


✅ Summary of Core Concepts:

Don’t return addresses of locals (dangling).

Always match new/delete, new[]/delete[].

Avoid double deletes (use smart pointers).

const_cast only safe if original object wasn’t const.

Always make base classes with virtual functions have a virtual destructor.

Function pointer signatures must match exactly.

Watch for cyclic references with shared_ptr, use weak_ptr.

#1.

struct A {
    void fun(int x) { cout << "A::fun " << x << endl; }
};

int main() {
    void (*fp)(int) = &A::fun;   // ❌ error
    A a;
    fp(10);
}
==> make fun is static as fun is non static fun or
int main() {
    void (A::*fp)(int) = &A::fun;   // pointer-to-member
    A a;
    (a.*fp)(10);                    // call through object
}

#2.
#include <new>
#include <iostream>
using namespace std;

int main() {
    char buffer[sizeof(int)];
    int* p = new(buffer) int(42);   // construct in buffer
    cout << *p << endl;

    p->~int();   // ✅ explicitly call destructor
    // Do NOT delete p, memory is owned by buffer
}

#include <new>
#include <iostream>
using namespace std;

struct MyClass {
    int x;
    MyClass(int v) : x(v) { cout << "Constructed with " << v << endl; }
    ~MyClass() { cout << "Destroyed " << x << endl; }
};

int main() {
    alignas(MyClass) char buffer[sizeof(MyClass)]; // raw memory
    MyClass* obj = new(buffer) MyClass(99);        // placement new
    cout << obj->x << endl;

    obj->~MyClass();  // ✅ manually call destructor
    // no delete, buffer is stack memory
}

#3.

#include <iostream>
using namespace std;

int main() {
    double d = 3.14;
    int* p = reinterpret_cast<int*>(&d);  // ❌ dangerous
    *p = 42;
    cout << d << endl;
}
🔎 What happens
reinterpret_cast<int*>(&d)

Treats the address of a double as if it were an int*.

But an int and a double have different sizes and representations in memory.

*p = 42;

Writes 4 bytes (int) into the first 4 bytes of the double.

Leaves the remaining bytes of the double uninitialized/unchanged.

Now d’s binary representation is corrupted.

cout << d;

Prints some garbage, undefined, maybe 2.07e-322 or some nonsense value.

This is undefined behavior under the C++ standard, because of the strict aliasing rule:

You cannot access an object of type double through an lvalue of type int* (except via char*/std::byte*).


#4.
int* raw = new int(5);
std::shared_ptr<int> sp1(raw);
std::shared_ptr<int> sp2(raw);  // ❌ issue
What’s happening:
raw points to a dynamically allocated integer (5).

sp1 takes ownership of raw. It will delete raw when sp1 goes out of scope.

sp2 also tries to take ownership of the same raw.

This is dangerous because both shared_ptr objects think they are the sole owner. When they are destroyed, they will both attempt to delete raw.

✅ This leads to double deletion, which is undefined behavior and can crash your program.

Correct ways to do this
1. Let shared_ptr manage the allocation directly:
cpp
Copy code
std::shared_ptr<int> sp1 = std::make_shared<int>(5);
std::shared_ptr<int> sp2 = sp1;  // ✅ Both share ownership safely
make_shared is the recommended way.

Both sp1 and sp2 now share ownership of the same memory safely.

2. If you already have a raw pointer (less recommended):
cpp
Copy code
int* raw = new int(5);
std::shared_ptr<int> sp1(raw);
std::shared_ptr<int> sp2 = sp1; // ✅ Copy constructor, safe
Do not create a second shared_ptr from the same raw pointer.

Key takeaway:
Never construct two shared_ptrs from the same raw pointer.

Always share ownership via copying an existing shared_ptr.

#5.
struct A { int x; };
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C {};

int main() {
    D d;
    A* ap = &d;  // ❌ does this work?
}
Key points:
B and C inherit virtually from A.

Virtual inheritance means there is only one shared A subobject in D.

D inherits from B and C.

So the memory layout of D roughly looks like this:

css
Copy code
      D
     / \
    B   C
     \ /
      A  <-- single A subobject (virtual)
What happens with A* ap = &d;?
d is of type D.

A is a virtual base, so it does exist uniquely in D.

But C++ does not allow an implicit conversion from D* to A* when A is a virtual base, because the compiler doesn’t know which path to take automatically.

✅ This line will not compile — it’s ambiguous in standard C++.

Correct ways:
Cast via one of the base classes:

cpp
Copy code
D d;
A* ap = static_cast<B*>(&d);  // ok, B has virtual A
or

cpp
Copy code
A* ap = static_cast<C*>(&d);  // also ok
static_cast tells the compiler which path to use.

Direct access using &d.B::A (rarely used):

cpp
Copy code
A* ap = &d.B::A;
Key takeaway:
When using virtual inheritance, a derived-to-base pointer conversion can become ambiguous.

You need explicit disambiguation (static_cast) if the base is virtual.

#6.
void update(int* a, int* b) {
    *a = 5;
    *b = *a + 1;   // ❌ potential hidden bug
}

int main() {
    int x = 1;
    update(&x, &x);
    cout << x << endl;
}
Step by step:
main calls update(&x, &x);

Both a and b point to the same variable x.

Inside update:

cpp
Copy code
*a = 5;          // x = 5
*b = *a + 1;     // *b = 5 + 1 = 6 ?
At first glance, it seems x should become 6.

But the C++ standard does not guarantee this. Why?

Why it’s unsafe:
*a = 5; modifies x.

*b = *a + 1; reads x and writes to x in the same statement.

a and b alias the same memory, so the compiler may reorder or optimize the operations.

This is undefined behavior (UB) because the same memory is modified twice without a sequence point between modifications (in pre-C++17 terms; in modern C++17+ rules, the compiler still has freedom for optimizations).

Some compilers may print 6, some 5, or do something unexpected.

Safe ways to write it:
Use a temporary variable:

cpp
Copy code
void update(int* a, int* b) {
    *a = 5;
    int temp = *a;
    *b = temp + 1;  // ✅ safe
}
Or avoid aliasing:

cpp
Copy code
int y = x;
update(&y, &x);

#7.





