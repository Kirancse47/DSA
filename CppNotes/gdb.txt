                                                                 GDB Cheat Sheet
Part - 1

#Starting gdb
gdb ./a.out                    # Start with executable
gdb ./a.out core               # Debug with core dump
gdb ./a.out <pid>              # Attach to running process

#Running Program
run arg1 arg2                  # Run program with args
start                          # Run and stop at main
continue / c                   # Resume execution

#Breakpoints
break main                     # Break at main
break 25                       # Break at line 25
break file.cpp:40              # Break at line 40 in file.cpp
tbreak main                    # Temporary breakpoint
delete 1                       # Delete breakpoint 1
info breakpoints               # Show all breakpoints

#Stepping
step / s                       # Step into function
next / n                       # Step over function
finish                         # Run until function returns
until                          # Run until loop/line exits

#Inspecting Code
list                           # Show source code
backtrace / bt                 # Show call stack
frame 2                        # Switch to frame 2
info locals                    # Show local variables
info args                      # Show function arguments

#Variables & Memory
print x                        # Print variable x
display x                      # Auto print x each step
set var x=10                   # Change variable value
x/4xw &arr                     # Examine memory (4 words hex)

#Threads
info threads                   # Show all threads
thread 3                       # Switch to thread 3
break foo if x==5              # Conditional breakpoint

#Watchpoints
watch x                        # Stop when x changes
rwatch x                       # Stop when x is read
awatch x                       # Stop on read/write

#Exiting
quit / q                       # Exit gdb


Part -2

1Ô∏è‚É£ How do you debug a core dump using GDB?

Question:
You have a program that crashed and generated a core file. How do you analyze it?

Answer:

gdb <executable> core


Inside GDB:

(gdb) bt          # shows stack trace
(gdb) info locals # inspect local variables
(gdb) frame 2     # switch to frame 2
(gdb) print var   # print variable values


Concept: GDB reads the executable‚Äôs symbols + the core dump‚Äôs memory snapshot ‚Üí full postmortem analysis.

2Ô∏è‚É£ How to debug a running process without restarting it?

Answer:
Attach GDB to a live process:

gdb attach <pid>


Then:

(gdb) bt        # get current stack trace
(gdb) info thr  # check threads
(gdb) detach    # resume execution safely


Use when debugging long-running daemons or services.

3Ô∏è‚É£ How do you set conditional breakpoints?

Example:

(gdb) break foo if x > 10 && y == 0


Execution stops only when the condition is true.

Use case: debugging logic only under specific input states ‚Äî crucial in large systems.

4Ô∏è‚É£ How do you inspect memory corruption or buffer overflow?

Answer:

(gdb) watch *ptr


‚Üí Triggers when the memory pointed by ptr changes.

Or use:

(gdb) x/20bx buffer


‚Üí Examine memory bytes around a buffer.

5Ô∏è‚É£ How do you debug multithreaded programs?

Common questions:

How do you see all threads?

(gdb) info threads


How to switch and inspect a specific thread?

(gdb) thread <id>
(gdb) bt


How to break on thread creation/death?

(gdb) set scheduler-locking on
(gdb) break pthread_create

6Ô∏è‚É£ How do you debug deadlocks or hangs?

Answer:
When a process hangs:

gdb -p <pid>


Then:

(gdb) thread apply all bt


‚Üí Prints backtrace of all threads ‚Äî shows who‚Äôs holding locks and who‚Äôs waiting.

7Ô∏è‚É£ How do you trace function calls (without adding printfs)?

Answer:

(gdb) break my_func
(gdb) commands
> silent
> printf "Entering my_func(%d)\n", x
> continue
> end


GDB executes this automatically each time my_func() is called ‚Äî acts like dynamic logging.

8Ô∏è‚É£ How to debug optimized (-O2) binaries?

Question: What issues occur with optimized builds?

Answer:

Variables may be optimized out (use info locals may show <optimized out>).

Function inlining hides call frames.

Fix:

Recompile with:

gcc -g -O0 prog.c -o prog


Or use:

set print pretty on
set var-disable off

9Ô∏è‚É£ How to change variable values at runtime in GDB?
(gdb) print var
(gdb) set var = 42
(gdb) continue


‚Üí Used for testing without recompiling.

üîü How to inspect heap allocations or leaks?

Combine with glibc hooks:

(gdb) break malloc
(gdb) commands
> silent
> printf "malloc(%d)\n", $rdi
> continue
> end


‚Üí Traces every dynamic allocation.

Or integrate with Valgrind + GDB:

valgrind --vgdb=yes ./a.out

Bonus: Useful GDB commands cheat
Purpose	Command
Run till function returns	finish
Step into function	step
Step over function	next
Display variable continuously	display var
Disassemble code	disas <function>
Load symbols dynamically	symbol-file <file>
Redirect output	set logging on
