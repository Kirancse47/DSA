@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
             						C++ NOTES
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

############################################################################
C++11 AND C++14
############################################################################
1) things added in c++14
	a) generic lambdas:
		-> c++11 lambdas 
			[](int a, int b) -> int { return a + b; }
		-> c++14 lambdas 
			template<typename T>
				[](T a, T b) -> T { return a + b };
	

	b) Return Type Deduction for Functions: 
		-> C++14 extended the auto type deduction to work with the return types of functions.
		-> auto func() {
						return 42; // deduces return type as int
					}
	
	c) enhancements in multithreading
		-> std::shared_timed_mutex introduced 

std::shared_mutex is a synchronization primitive that lets several threads use a shared resource simultaneously for reading while guaranteeing exclusive writing access.

############################################################################

############################################################################
ITERATOR IN C++
############################################################################

1) iterators are objects that points to data of containers
2) Different types of container
	a) Random - Access: 
			-> They are the most powerful iterators. They are not limited to moving sequentially, 
				as their name suggests, they can randomly access any element inside the container. 
			-> They are the ones whose functionality are same as pointers.
			-> strongest of all iteraors
			-> vector and dequeue support this iteraor
			
	b) bi-directional:
			-> increment and decrement supported
			-> list, map, multimap, set, multiset
			
	c) forward:
			-> only increment is supported.
			-> forward_list(singlt linked list), unordered set, unordered map, unordered multimap, unordered multiset
			
	d) input:
			-> istream_iterator
	e) output
			-> ostream_iterator

############################################################################


############################################################################
contianers in c++
############################################################################

1) list:(non-contiguous)
	a) internal implementation: doubly linked list
	b) iterator: bi-directional
	c) time complexity:
		-> insertion/deletion O(n)
		-> access O(n)

2) deque:(contiguous)
	a) internal implementation: arrays
	b) iterator: random access 
	c) time complexity:
		-> insertion/deletion O(n)
		-> access O(1)  //similar to vector( diff some extra functions for front and back)

3) vector:(contiguous)
	a) internal implementation: arrays
	b) iterator: random access 
	c) time complexity:
		-> insertion/deletion O(n)
		-> access O(1)  

4) set and multiset: non-contiguous
	a) internal implementation: self balancing binary tree  (red black tree)
	b) iterator: bi-directional
	c) time complexity:
		-> insertion/deletion O(logn)
		-> access O(logn) 
		
5) map and multimap: non contiguous
	a) internal implementation: self balancing binary tree  (red black tree)
	b) iterator: bi-directional
	c) time complexity:
		-> insertion/deletion O(logn)
		-> access O(logn) 

6) unordered set:
	a) internal implementation: hash data structure 
	b) iterator: forward 
	c) time complexity:
		-> insertion/deletion average O(1) and worst case O(n)
		-> access O(1)

7) unordered map:
	a) internal implementation: hash data structure 
	b) iterator: forward 
	c) time complexity:
		-> insertion/deletion average O(1) and worst case O(n)
		-> access O(1)
############################################################################



############################################################################
OOPS
############################################################################

1) Class and Objects:
2) Encapsulation: 
		It involves bundeling of data members and member functions, and promotes access control and data hiding by making them public, 
		private and protected.
		* Acess control: The encapsulation ensures that the internal state of the object is protected from unauthorized access and modification.
		* Data hiding: 
		* setter and getter
		
3) Inheritance:
		it is one of a core principles of oop by which one class uses the property and attributes of another class.
		It is a "IS-A" relationship ('maruti' is a 'car')
		* Acess control:
			PUBLIC: 
				-> public members of base class will be public for derived class 
				-> protected members will be protected 
				-> private members will not be accessible
			
			PROTECTED:
				-> public members of base class will be protected
				-> protected will be protected
				-> private will not be accessible 
				
			PRIVATE:
				-> public members of base class will be private in derived class
				-> protected members will be private
				-> private will not be accessible
		* Types
			-> Single inheritance
			-> Multiple inheritance:
				class Derived : public Base1, public Base2
			-> Multilevel inheritance:
				class Grandparent, 
				class Parent : public Grandparent, 
				class Child : public Parent
			-> Hierarchical inheritance:
				class Animal, class Dog : public Animal, class Cat : public Animal
		
4) Polymorphism:
		It allows objects of different classes to be treated as objects of a common base class, providing flexibility and extensibility in your code.
		It is often achieved by virtual functions (method overriding).
		Abstrat class: A class having one pure virtual function.
			pure virtual function is a virtual fucntion asigned to 0, that means it must be defined in its derived class.
	    Dynamic binding (run time polymorphism)
		
		Types:
			1) Compile Time:
				a) function overloading
				b) operator overloading
			2) Run time:
				a) virtual functions 
				b) function overriding
		for virtual concept search for (VIRTUAL TABLE AND VIRTUAL POINTER)
5) Abstraction:
		-> it allows to decide what information to be displayed to the outer world and which is not (via public and private accessfier)

############################################################################



############################################################################
				types of constructor
############################################################################


#if 0
#include <iostream>
using namespace std;
class abc
{
    public:
    int a;
    int b;
    //default constructor
    abc()
    {
        
    }
    //parametrized constructor
    abc(int x, int y)
    {
        a= x;
        b= y;
    }
    //copy constructor
    abc(const abc &x)
    {
        a = x.a;
        b = x.b;
    }
};
int main() {
    // Write C++ code here
    std::cout << "Hello world!";
    abc obj1(900,89990);
    cout<<obj1.a;
    //abc obj2 = obj1;
    abc obj2(obj1);
    cout<<obj2.a;
    return 0;
}
#endif

&&&&&&&&&&&&&&&&&&&&&&&&&&
note:
shallow copy: 
	1) default copy constructor (gets created for each class if no copy constructor is defined)
	2) happens only in heap memory
	3) also as arguments are passed by address, change in one argument will affect other object as well
deep copy: 
	1) user defined copy constructor
	2) happens only in heap memory
	2) no memory is shared between objects
	
		#include <iostream>
		#include <cstring>
		using namespace std;

Example: 	
		class MyString {
		    char* str;
		
		public:
		    // Constructor
		    MyString(const char* s) {
		        str = new char[strlen(s) + 1];
		        strcpy(str, s);
		    }
		
		    // Copy Constructor (Deep Copy)
		    MyString(const MyString& other) {
		        str = new char[strlen(other.str) + 1];
		        strcpy(str, other.str);
		    }
		
		    // Assignment Operator (Deep Copy)
		    MyString& operator=(const MyString& other) {
		        if (this != &other) {   // protect against self-assignment
		            delete[] str;
		            str = new char[strlen(other.str) + 1];
		            strcpy(str, other.str);
		        }
		        return *this;
		    }
		
		    // Destructor
		    ~MyString() {
		        delete[] str;
		    }
		
		    // Utility function
		    void print() const {
		        cout << str << endl;
		    }
		};
		
		int main() {
		    MyString s1("Hello");
		    MyString s2 = s1;   // invokes copy constructor
		    s1.print();
		    s2.print();
		    return 0;
		}
	#observation :
	1)Copy constructor → runs when a new object is created from another.
		MyString s2 = s1;  // copy constructor
	2)Assignment operator → runs when an already existing object is assigned a new value.
	MyString s2("World");
	s2 = s1;           // assignment operator


	SUMMARY:
	1) suppose there is a class having one pointer that is pointing to memory address xABCD, now we created an other object that is 
	shallow copy of the existing one, what will happen,
	the created object will also point to the same xABCD memory location. (both the object will share the resources)
	to avoid this, we use deep copy, in which if there is any pointer or dynamic thing happening, we will do the same for the newly 
	created object so that they do not share any common resource.
	hence we will have to delete those allocated resources in destructor explictley.
	
	2) constructor can be overloaded but destructor can not be as destructor can not have any argument.
	3) both constructor and destructor can be private, constructor is made private to controll the object creation i.e. singleton class
	e.g.
	class MyClass {
private:
    MyClass() {
        // Private constructor
    }

public:
    static MyClass& getInstance() {
        static MyClass instance;
        return instance;
    }

    void someFunction() {
        // You can use the public members and methods here
    }
};


Note: 
1) in case of inheritance, constructor of base is executed first and destructor is called last
	syntax:
		class B (base)
		class C : public B
		{
			C():B()   // default constructor of base class is called first by constructor of child class
			{
			}
		}
	a) Note: compiler only calls default constructor of base class, in case of base class having parametrized constructor(there will be no default constr)
			, its base class's responsibility to call the paramatrized constructor manually to avoid errors
			
		//code 
			class base
			{
				int a;
				public:
			   
				base(int x)
				{
					std::cout<<"base class constructor is called"<<std::endl;
					a = x;
				}
			};


			class child:public base
			{
			   public:
				child():base(5)
				{
					std::cout<<"child constructor is called"<<std::endl;
				}
				
			};
			 
		

2) a constructor can be private, as while creating object, constructor will be called from outside of the class, if no object
   is to be created for that class, it can have a private constructor	 
   
3) a destructor can be private with same above reason. Either if no object has to be created or 
	if object is created with new operator, it is possible to have private destructor as 
	compiler assumes that is is programmer's responsibility to delete that memory
   
4) a constructor can never be static, as function of constructor is to initialize the member variables of an instance. and static fucntions 
   have nothing to do with member variables.

5) a destructor can never be static with the same above reason.

6) a constructor can never be virtual as when constructor of a class is executed, there is no virtual table in the memory so no virtual pointer 
   is defined.
7) a destructor can be virtual, making a destructor virtual ensures that space occupied by both parent and child classes will be freed.
	ORDER OF CONSTRUCTOR AND DESTRUCTOR CALL:
		1) constructor of parent is called 
		2) constructor of child is called
		3) destructor of child is called
		4) destructor of parent is called
8) a constructor can never be cosnt, as fucntionality of constructor is to initialize data members of an instance and const says that the 
   function can not change the data members.
9) const destructor can never be destructor 
10) constrructor and destructor are instance member functions
&&&&&&&&&&&&&&&&&&&&&&&&&&&


####################################################################################


####################################################################################
		template and implementation of our own stl (generic programming)
####################################################################################

=> a mechanism that provides facility of providing data types as argument to make the program generic
=> ADVANTAGES: 
	1) Code Reusability:  A simple function or class or structure can be used for multiple data data types.
	2) Type Saftey: Compiler perform type checking at compile time.
=> DISADVANTAGES:
	1) Compilation Time: Same code is duplicated by compiler for each different types.



%%%%%%%%%%%%%%%%%%%%%%%
template syntax
%%%%%%%%%%%%%%%%%%%%%%%

	
	template<typename T>
	void swap1(T &a, T &b)
	{
		T temp = a;
		a =b;
		b =temp;
		return;
	}

	int main() {
		string s = "bhaskar";
		string t = "jaiswal";
		swap1(s, t);
		cout<<s<<" "<<t<<endl;
		int x =10, y =1;
		swap1(x,y);
		cout<<x<<" "<<y;
		return 0;
	}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
implementation of vector stl
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

template<typename T> class myVector{
    int length = 0;
    struct node
    {
        T value;
        node* next;
    };
    public:
    myVector(int size, T value)
    {
        for(int i=0; i<size; i++)
        {
            push_back(value);
        }
        cout<<"vector of size "<<size<<" "<<"is created with all initial value: "<<value<<endl;
        print_my_vector();
    }
    node* head = NULL;
    int size()
    {
        return length;
    }
    void push_back(T data)
    {
        node* new_node = new node;
        new_node->value = data;
        new_node->next = NULL;
        if(head == NULL)
        {
            head = new_node;
        }
        else
        {
            node* temp = head;
            while(temp->next != NULL)
            {
                temp =temp->next;
            }
            temp->next = new_node;
        }
        length++;
        return;
    }
    
    void pop_back()
    {
        if(head == NULL)
        {
            cout<<"vector is empty";
            return;
        }
        node* temp = head;
        if(head -> next == NULL)
        {
            delete(head);
            head = NULL;
        }
        else
        {
            node* temp = head;
            while(temp->next->next != NULL)
            {
                temp = temp->next;
            }
            delete(temp->next);
            temp->next = NULL;
        }
        length--;
        return;
    }
    void pop_front()
    {
        if(head == NULL)
        {
            cout<<"vector is empty"<<endl;
        }
        else
        {
            node *temp = head;
            head = head->next;
            delete(temp);
            temp = NULL;
        }
        length--;
        return;
    }
    void pop_back(int count)
    {
        for(int i=0; i<count; i++)
        {
            pop_back();
        }
        return;
    }
    void pop_front(int count)
    {
        for(int i=0; i<count; i++)
        {
            pop_front();
        }
        return;
    }
    
    void print_my_vector()
    {
        node* temp = head;
        while(temp != NULL)
        {
            cout<<temp->value;
            temp = temp->next;
        }
        cout<<endl;
    }
};

int main()
{
    myVector<int> v1(10, 4);
    for(int i=0; i<5; i++)
    {
        v1.push_back(i);
    }
    cout<<v1.size()<<endl;
    v1.print_my_vector();
    v1.pop_back();
    cout<<v1.size()<<endl;
    v1.print_my_vector();
    v1.pop_front();
    cout<<v1.size()<<endl;
    v1.print_my_vector();
    //accessing with index
    //sorting a linked list to sort a vector
    //initilization (multiple types)
    //iterator
}
#endif

##############################################################################







##############################################################################
cosnt keyword
##############################################################################


possibilites:
	1) const int variable = some_value;                //cosntant variable
		#variable that is of type int and it is constant
		#value of this variable cant be changed (hence initilization required)
		
	2) int* const pointer = &some_variable;            //constant pointer
		#there is a pointer which is constant and pointing to integer type
		#alaways points to same address
		
	3) const int* pointer = &some_variable;            //pointer to constant variable
		#there is pointer pointing to int type variable that is constant
		#also can be declared as int const* pointer = &some_variable;
		
	4) foo(const int x)                                //constant function argument
		#there is an argument which is of type int and is constant
		#x cant be changed inside the function
		
	5) return_type member_func()const{}                //const member function
		#there is a constant member function of type return type
		#constant member function of a class that never changes any class data members, 
			and it also never calls any non-const function .
		#It is also known as the read-only function.
		#We can create a constant member function of a class by adding the const keyword after the name of the member function.
		#uses to be checked
		
	6) const data_type data_member                     //const data member of a class
		#there is a data member of type data_type and is constant
		#value can be assigned only in constructor
		
	7) const class_name obj;                           //const obj of a classs
		#there is an object of type class_name and it is constant
		#in case of const objects, class must have constructor from where objects can initialize their members
		
	Note: const data members cant be initialized at the time of declaration(in previous versions, now it can be)
		WAYS TO INITIALIZE CONST DATA MEMBER:
			1) make it static const and initialize at declaration
				static const int a = 10; //at declaration
			2) make static const and initilize outside the class:
				class A
				{
				  static const int a; //declaration
				};

				const int A::a = 10; //defining the static member outside the class
			3) initialize it with constructor (not in constructor) via list initializer
				class A
				{
				  const int b;
				  A(int c) : b(c) {} //const member initialized in initialization list
				};
	Places where list initializer is must (places where initialisaion is to be done at that instant)
		1) initializing const data members
		2) initializing reference data members
		3) in case of inheritance (to initialize data members of base class if derived one is having any paramatrized constructor)
				
				
		
	
###############################################################################
	
	
	
############################################
MEMORY LAYOUT IN C++
############################################

The memory layout in C++ can be complex, as it involves various memory regions and how data is organized within those regions. 
Here's an overview of the typical memory layout in a C++ program:

	Code Section:
		The code section, also known as the text section, contains the compiled machine code instructions of the program. 
		This is where the actual executable code resides.

	Data Section:
		Initialized Data (Data Segment): This section contains global and static variables that are explicitly initialized with values. 
		These variables have a specific memory location and are stored in the data segment. Static member variables of classes are often located here.

	Uninitialized Data (BSS Segment): 
		Uninitialized global and static variables (variables without explicit initialization) are 
		stored in this section. 
		The memory for these variables is allocated but not initialized with specific values. It is called the BSS (Block Started by Symbol) segment.

	Heap:
		The heap is a dynamically allocated memory area that is managed by functions like new (in C++) or malloc (in C). 
		It is used for dynamic memory allocation, such as creating objects and data structures at runtime. Memory allocated on the heap 
		needs to be explicitly deallocated to prevent memory leaks.

	Stack:
		The stack is used for function call management and storing local variables. When a function is called, a new stack frame is created to 
		store function parameters, local variables, and return addresses. 
		The stack follows a last-in-first-out (LIFO) order, which means the most recently called function's stack frame is at the top.

	Constants and Read-Only Data:
		Constants, string literals, and read-only data are often stored in a separate read-only data section. This data is not modifiable during 
		program execution.
		
	Code, Instructions, and Libraries:
	The program's executable code, as well as any libraries or external functions it depends on, are loaded into memory and placed in 
	appropriate sections. 
	These sections contain the instructions needed for program execution.
	
	Memory Management Structures:
	The runtime environment may include memory management structures like the heap's free list, which keeps track of available memory 
	blocks for allocation.
	Dynamic Memory Pools (optional):

	In some applications, custom memory management schemes or memory pools may be used to allocate and manage memory efficiently for 
	specific data structures or objects.
	The exact memory layout of a C++ program can vary based on the compiler, platform, and program's architecture. 
	Additionally, memory layout optimizations and features like virtual memory can further complicate the layout.
	Understanding the memory layout of your program is important for memory management, performance optimization, and debugging 
	memory-related issues.
	

#####################################################################################################################################################





#####################################################################################################################################################
                                                   STATIC KEYWORD
#####################################################################################################################################################

1) STATIC LOCAL VARIBALE: 
	-> memory will be allocated at once
	-> get memory once program starts and get deallocated once program ends
	-> belongs to data segement, (initialized data segement, hence int is initilizes with 0)
2) STATIC MEMBER VARIABLE:
	->common for all objects
	->can be accessed with and without object
3) STATIC MEMBER FUCNTION:
	->common for all objects
	->can be accessed with and without object
	->can only access static member but in case of creating one object inside that static member function can access non static members as well
	
################################################################################################################################################






############################################################################################################################################
													OPERATOR OVERLOADING
############################################################################################################################################

Any operator (except sizeof and ? (conditional)) that exists for primitive data type can be overloaded for user defined data types to change its
functional behaviour.

#include <iostream>

using namespace std;

class bhaskar
{
    public:
    int data;
    bhaskar operator +(bhaskar b1)
    {
        bhaskar temp(0);
        temp.data = data + b1.data;
        return temp;
    }
    bhaskar(int x)
    {
        data = x;
    }
    void show_data()
    {
        cout<<data;
    }
};



int main()
{
    cout<<"Hello World";
    bhaskar b1(5), b2(5);
    bhaskar b3 = b1 + b2;
    b3.show_data();
    return 0;
}



##UNARY OPERATOR OVELOADING

#include <iostream>

using namespace std;

class parent
{
    private:
    int x,y;
    public:
    void show_data()
    {
        cout<<x<<" + "<<y<<"i"<<endl;
    }
    parent operator+(parent c2)
    {
        parent temp(0,0);
        temp.x = x + c2.x;
        temp.y = y + c2.y;
        return temp;
    }
    
    parent operator++()
    {
        parent temp(0,0);
        temp.x = x++;
        temp.y = y++;
        return temp;
    }
    
    parent operator++(int)
    {
        parent temp(0,0);
        temp.x = ++x;
        temp.y = ++y;
        return temp;
    }
    
    
    parent(int real, int img)
    {
        x = real;
        y = img;
    }
    
};


int main()
{
    cout<<"Hello World"<<endl;
    parent n1(4,3);
    parent n2(3,4);
    parent n3 = n1.operator+(n2);
    n3.show_data();
    n3.operator++();
    n3.show_data();
    parent n4 = ++n3;
    n3.show_data();
    n4.show_data();
    return 0;
}

//output

Hello World
7 + 7i
8 + 8i
9 + 9i
8 + 8i


#####################################################################################################################################################







#######################################################################################################################################
TYPE CASTING
#######################################################################################################################################

1) IMPLICIT TYPE CASTING:
	char -> short int -> int -> unsigned int -> long int -> float -> double -> long double, etc.  (lower -> higher maintains data precision)
	Note: Implicit Type Casting should be done from low to higher data types. Otherwise, it affects the fundamental data type, 
	which may lose precision or data, and the compiler might flash a warning to this effect.
	example:
	int to float -> no precision loss
	float to int -> decimal values will be lost

2) EXPLICIT TYPE CASTING:
	i) static_cast
	
		#include <iostream>
		using namespace std;

		class animal
		{
			public:
			string name;
			int age;
			void speak()
			{
				cout<<"I am an animal"<<endl;
			}
		};

		class dog : public animal
		{
			public:
			bool loyal;
			void bark()
			{
				cout<<"I bark"<<endl;
			}
		};


		class cat : public animal
		{
			public:
			void mewos()
			{
				cout<<"I mewos"<<endl;
			}
		};

		int main()
		{
			dog d;
			d.loyal = true;
			animal a = static_cast<animal>(d);
			a.name = "bhura";
			a.age = 34;
			a.speak();
			d.speak();
			
			return 0;
		}
		
	
   ii) dynamic_cast
		* run time casting only for class pointer and references
		* run time checks
		* in case of invalid cast will result to null pointer or bas::bad_cast exception
        * To work with dynamic_cast, there must be one virtual function in the base class.
#include <iostream>
using namespace std;

class Base {
    virtual void print() {
        cout << "Base" << endl;
    }
};

// Derived1 class declaration
class Derived1 : public Base {
    void print() {
        cout << "Derived1" << endl;
    }
};

// Derived2 class declaration
class Derived2 : public Base {
    void print() {
        cout << "Derived2" << endl;
    }
};

int main() {
    Derived1 d1;
    Base* bp = &d1;

    // Dynamic Casting
    Derived2* dp2 = dynamic_cast<Derived2*>(bp);
    if (dp2 == nullptr)
        cout << "Casting Failed" << endl;
    else
        cout << "Casting Successful" << endl;

    return 0;
}
		
   iii) const_cast
#include <iostream>
using namespace std;

int main() {

    int n = 5;
  
    // Pointer to a const int
    const int* ptr = &n;

    // int* nonConstPtr = ptr; if we use this
    // instead of without using const_cast
    // we will get error of invalid conversion
    int* nonConstPtr = const_cast<int*>(ptr);
    *nonConstPtr = 10;

    cout << *nonConstPtr;

    return 0;
}
   iv) interpret_cast
	// CPP code to illustrate using structure
#include <bits/stdc++.h>
using namespace std;

// creating structure mystruct
struct mystruct {
    int x;
    int y;
    char c;
    bool b;
};

int main()
{
    mystruct s;

    // Assigning values
    s.x = 5;
    s.y = 10;
    s.c = 'a';
    s.b = true;

    // data type must be same during casting
    // as that of original

    // converting the pointer of 's' to,
    // pointer of int type in 'p'.
    int* p = reinterpret_cast<int*>(&s);

    cout << sizeof(s) << endl;

    // printing the value currently pointed by *p
    cout << *p << endl;

    // incrementing the pointer by 1
    p++;

    // printing the next integer value
    cout << *p << endl;

    p++;

    // we are casting back char * pointed
    // by p using char *ch.
    char* ch = reinterpret_cast<char*>(p);

    // printing the character value
    // pointed by (*ch)
    cout << *ch << endl;

    ch++;

    /* since, (*ch) now points to boolean value,
    so it is required to access the value using 
    same type conversion.so, we have used 
    data type of *n to be bool. */

    bool* n = reinterpret_cast<bool*>(ch);
    cout << *n << endl;

    // we can also use this line of code to
    // print the value pointed by (*ch).
    cout << *(reinterpret_cast<bool*>(ch));

    return 0;
}


##########################################################################################################################################



##########################################################################################################################################
										VIRTUAL TABLE AND VIRTUAL POINTER
##########################################################################################################################################
=> In case of a class having virtual functions, compiler adds one vptr (pointer) as a member of that class.
=> this vptr points to a table (2 dimensional array) called vtable which contains function pointers.
=> on runtime, based on the type of memory base class object is allocated, that vptr is used to call functions.
=> e.g. if base class object pointer is pointing to memory location of child class type, vptr of child class will be used to 
	call the functions of child classes.
	
=> ADVANTAGES:
	1) Allows base class pointer to invoke required function at run time.

=> DISADVANTAGES:
	1) RUN TIME OVERHEAD: vptr and vtable increases run time as processing is needed to allocate space for each instance 
		hence increasing processing time.
	2) Memory Overhead: presence of vptr and vtable for each instance accquires memory.
=> (see screen shot of vtable and vptr)



#########################################################################################################################################

#########################################################################################################################################
					SIZE OF USER DEFINED DATA TYPES
#########################################################################################################################################

	// Online C++ compiler to run C++ program online
	#include <iostream>

	class parent
	{
		int a;
		char b;
	};
	struct child
	{
		
	};

	enum bhaskar
	{
		
	};
	enum jaiswal
	{
		apple
	};

	typedef int kalu;

	int main() {
		// Write C++ code here
		parent a;
		std::cout<<"class "<<sizeof(a)<<std::endl;
		child b;
		std::cout<<"empty structure "<<sizeof(b)<<std::endl;
		bhaskar b1;
		std::cout<<"empty enum "<<sizeof(b1)<<std::endl;
		jaiswal j1;
		std::cout<<"filled enum "<<sizeof(j1)<<std::endl;
		
		kalu k1;
		std::cout<<"typedef "<<sizeof(k1)<<std::endl;
		return 0;
	}
	===================================================
	OUTPUT
	class 8
	empty structure 1
	empty enum 4
	filled enum 4
	typedef 4
	===================================================




	1) size of an empty class is 1 byte
	2) size of an class having one int member is 4 bytes
	3) SIZE OF ENUM is same as the size of data type it is having
	4) structure size is 1 if empty otherwise sum of size of all the members with padding 
	5) in case of inheritance, size depends on below points
		-> data members of a base and derived class 
		-> padding
		-> virtual inheritance and virtual functions: in case of a class having virtual function or virtually inherited from another class
			there will be an extra member added by compiler that is called virtual table pointer, that will adds to the size of the object
			* without inheritance:
				class a1{
					public:
					int a;double c;char b;
					a1(){cout<<"constructor called for a1"<<endl;}
					};
				class b //:public a1
				{
					public:int x;int y;int z;int z1;
					b(){cout<<"constructor called for b"<<endl;}
				};
				int main() {b obj_b;std::cout<<sizeof(obj_b); //size is 16 bytes
					return 0;
				}
			
			* with inheritance:
				class a1{
					public:
					int a;double c;char b;
					a1(){cout<<"constructor called for a1"<<endl;}
					};
				class b :public a1 //inheritance
				{
					public:int x;int y;int z;int z1;
					b(){cout<<"constructor called for b"<<endl;}
				};
				int main() {b obj_b;std::cout<<sizeof(obj_b);//size is 40 bytes
					return 0;
				}
				
			* with virtual functions
				8 bytes of vptr will get added  also padding will change to 8 bytes packing
			Note: in case of inheritace, padding may change based on the class having the largest data member of primitive type.
			
	6)for more details, refer https://thoughts-on-coding.com/2020/09/14/structure-padding-in-cpp/

###################################################################################################################


###################################################################################################################
						STRUCTURE AND CLASS PADDING
###################################################################################################################

struct{
	char a; 
	char b;
	int c;
};


=> If we create any object of this structure, contiguous memory will be allocated for the members a, b, c.
=> Based on the preocessor, it is decided that in one CPU cycle how much bytes of data can be read.
	a) 32 bit means 4 bytes of data in a CPU cycle (1 Word = 4 bytes)
	b) 64 bit means 8 bytes of data in a CPU cycle
=> Now, if we see the memory allocation for an object of this cstructure
	it will be a1 b1 c1 c2 c3 c4    (a1 b1 c1 c2 c3 c4 are of one byte each)
	now while accessing a and b it can be done in one cpu cycle (as we can read 4 bytes), but if we try to read "c", it will take 2 
	CPU cycles (1 CPU cycle to access a1 b1 c1 c2 (4 bytes) and then another cycle for c3 and c4.
=> Here we can observe that to read an integer data type, it is taking two cycles of CPU to read that. 
	To minimise this number of cycles, the concept of padding was introduced

=> In padding, what compiler does is it creates 2 bytes of empty space as below
	a1 b1 _ _ c1 c2 c3 c4
	Now if c is to be accessed, it will onle take 1 CPU cycles.

=> Padding is automatically done by the compiler
=> Padding also can be controlled by the programmers in two ways
	1) #pragma pack(1) : here "1" means packaging will be done with one byte (means no padding)
		#pragma pack(1)  
		struct base  
		{  
			int a;  
			char b;  
			double c;  
		};  
		int main()  
		{  
			struct base var; // variable declaration of type base  
			// Displaying the size of the structure base  
			printf("The size of the var is : %d", sizeof(var)); 
			//it will return 13 bytes
			return 0;  
		}  
	2) By using attribute
		struct base  
		{  
			int a;  
			char b;  
			double c;  
		}__attribute__((packed));  ;  
		int main()  
		{  
			struct base var; // variable declaration of type base  
			// Displaying the size of the structure base  
			printf("The size of the var is : %d", sizeof(var));  
			//will return 13 bytes
			return 0;  
		}  
	
###################################################################################################################


###################################################################################################################
STL MAP
###################################################################################################################

1) implemented as a self balancing red black tree.
2) search complexity: o(log(n))
3) preffered for small input (for huge data, hash is preffered)
4) two self balancing trees are there 
	a) Red black tree: balancing cost is less (requires less number of rotations than AVL trees), time complexity(searching, sorting, deletion) is O(log(n)),
		same is AVL trees
		if search, insert, delete is frequently required, Red Black tree is preffered
	b) AVL trees: trees are more balanced
		if search is only frequently required, AVL trees are preffered
	



###################################################################################################################

###################################################################################################################
RED BLACK TREE
###################################################################################################################

properties:
1) root is always black
2) leaf node (null node of each leaf) is black
3) red parents have black node and vice versa
4) Depth Property: all the leaves have the same black depth
5) Path Property: all simple path from root to leaf node contains same number of black nodes

advantages:
	1) time complexity for search, delete, insert all are O(log(n)), n is number of nodes



###################################################################################################################



###################################################################################################################
SMART POINTERS
###################################################################################################################

1) in c++ its programmer's responsiblity of memory management
2) resulting mem leak, dangling pointers, double free, out bound reach
3) to resolve these issues, concept of smart pointer has come
4) using smart pointers, we do not need to deallocate the allocated memory as it gets deleted by itself once object goes out of scope

TYPES OF SMART POINTERS:
1) UNIQUE_POINTERS:
	a) memory ownership will be with only one pointer. no two pointers can point to the same memory.
	b) if any other pointer has to point to the same memory, ownership will have to move from previous to next pointer using function "move".
2) SHARED_POINTERS:
	a) two pointers can point to the same memory location
	b) memory will getdeleted once all the pointers are out of scope ( to check is all pointers are out of scope or not, shared pointers have 
		one member called "reference_count".
	c) use_count() function can be used to print the number of pointers pointing to the same memory location
3) WEAK_PONTERS:
	a) weak_ptrs are same as shared_ptr, only difference is when you create one weak pointer to shared_ptr, reference count will not increase
		and once shared_ptr goes out of scope, memory will be deleted.
	b) weak ptr is used to trac a memory location if it is still pointed by some other pointer with the help of function ".lock()"
###################################################################################################################


###################################################################################################################
							MALLOC vs NEW
###################################################################################################################

1) NEW calls constructor where malloc does not
2) NEW is an operator and malloc is a fucntion
3) NEW returns exact data type of which it is allcoating memory where malloc returns void*
4) in case of failure,new returns bad_alloc_expection where as malloc return NULL
5) NEW doesnot allow to change the buffer size where as malloc allows using realloc function
6) required size of memory block is calculated by compiler based on data type, where for malloc we have to provide the size 

Note: Heap and free store are two different thing
	Dynamic memory area has two partionions, Heap, and Free store. All new, delete happen in this Free store where malloc, realloc and free happen
	in Heap.
###################################################################################################################


###################################################################################################################
							FRIEND KEYWORD
###################################################################################################################
FREIND CLASS:
	1) a friend class can access public, private and protected members of the class of which it is declared friend
	class foo
	{
		private:
		int a;
		public:
		foo():a(10)
		{
			std::cout<<"constructor called for foo"<<std::endl;
		}
		friend class boo;
	};
	class boo
	{
	  int c;
	  public:
	  boo()
	  {
		  std::cout<<"constructor called for boo"<<std::endl;
	  }
	};
	int main() {
		boo b1; //constructor of only boo will be called
		std::cout<<b1.a; //will throw error, no member named a
		return 0;
	}
FRIEND FUNCTION:
	1) friend function can also access and manipulate the private members of the class
	2)HOW:
		a) Global Fucntion
			class abc{
				friend void foo(abc &obj);
			}
			void foo(abc &obj);
		b) function of another class:
			class a{
				void foo(a &obj);
			}
			class b{
				friend void a::foo(a &obj);
			}
				

###################################################################################################################							

###################################################################################################################
STAGES OF CODE COMPILATION
###################################################################################################################

1) PREPROCESSING: #define, #include, macros expansion and inline expansion occurs
2) COMPILATION: preprocessed code is fed to compiler to convert it into assembly language
3) ASSEMBLY: assembler converts assembly code into object code
4) LINKING: linker links all the multiple object files, dependent libraries into single executable or shared library

Flags used with gcc/g++ command
1) -o 		-> to change the name of bianry
2) -Wall 	-> print every warning in the code (like un initialised variables)
3) -l (L) 	-> to link shared library (e.g. gcc main.c -o main -lpthread
4) -E 		-> to get the pre processed code (first stage of compilation)
5) -S 		-> to get the assembly code
6) -C 		-> to get the compiled code without linking
7) -Werror	-> to treat all the warnings as error
8) -v 		-> verbose (to display internal compilation output to console)
9) -w           -> to disable all the warnings 




###################################################################################################################

###################################################################################################################
INLINE FUNCTION
###################################################################################################################

INLINE FUNCTION:
1) its a request to compiler, compiler may or may not expand it
2) inline function's variable somehow use register, so using too many variables inside inline function is a drawback
3) WHY INLINE FUNCTIONS ARE USED: in usual scenario, below steps are sequence of execution for a function call
	a) CPU stores the address of instruction having fucntion call.
	b) copying the arguments to the stack
	c) transferring the control to that fucntion
	d) function execution and storing return type in memory/register
	e) returning control back to callee fucntion
	
	for the above steps, two types of cost are there
	1) time to call that function (steps a to c)
	2) function execution time

4) ADVANTAGES OF INLINE FUNCTION:
	a) no function call overhead
	b) saves the time of pushing and popping the variables in the stack
	c) overhead of returning the flow to callee again

5) DISADVANTAGES OF INLINE FUNCTION:
	a) added variables in inline functions consume additional register
	b) if inline function is called from too many places, binary size will increase as same repeated code will get added at each callee
	c) a single change in an inline function will reflect change at each callee

###################################################################################################################




###################################################################################################################	

###################################################################################################################
LAMBDA FUNCTION/EXPRESSIONS IN C++
###################################################################################################################

1) fucntions without name hence non reusable
2) kind of inline functions
3) possible syntax
	1)[]()->return_t{}();   
	2)"->return_t" part can be ignored as compiler impicitly can decide the return type, but for few cases,
		it should be written explicitly
		[capture clause](parameters){fucntion body}; // ";" is just like semicolon at the end of calling any function with name
		
	3) Examples:
	  a)
		int main()
		{
			int a=4, b=5;
			[](int a, int b)->void{std::cout<<a<<" "<<b;}(a,b);
			
		}
	  b)
		int main()
		{
			int a=4, b=5;
			[=]()->void{std::cout<<a<<" "<<b;}();
			// here "equal in capture clause tells that this function have copies of all the variables of parent funtion (main)"
			// immutable lambda function
			
		}
	  c) 
	    int main()
		{
			int a=4, b=5;
			[&]()->void{std::cout<<a<<" "<<b;}();
			// here "& in capture clause tells that this function have refrence of all the variables of parent funtion (main)"
			//mutable lambda function
			
		}
	  d) 
	    int main()
		{
			int a=4, b=5;
			[]()->void{std::cout<<a<<" "<<b;}();
			// this code will throw error as lambda function dont have access to parent function's variable implicitly
			
			
		}


###################################################################################################################
					
					
###################################################################################################################
FUNCTORS
###################################################################################################################
- FUNCTORS are functions wrapped inside a class with overloaded "()" function call operator so that we can call the function with object 
	of that class
- also known as function objects
- commonly used with STL
- an object that can be called as function by overloading function call operator "()"
example:
	
#include <iostream>
class parent
{
    public:
        void operator()(int a, int b)
        {
            std::cout<<a<<" "<<b<<std::endl;
        }
};
int main() {
    parent p1;
    p1(4,5);
    return 0;
}





example2:

#include <bits/stdc++.h>
using namespace std;

// A Functor
class increment
{
private:
	int num;
public:
	increment(int n) : num(n) { }

	// This operator overloading enables calling
	// operator function () on objects of increment
	int operator () (int arr_num) const {
		return num + arr_num;
	}
};

// Driver code
int main()
{
	int arr[] = {1, 2, 3, 4, 5};
	int n = sizeof(arr)/sizeof(arr[0]);
	int to_add = 5;

	transform(arr, arr+n, arr, increment(to_add));

	for (int i=0; i<n; i++)
		cout << arr[i] << " ";
}

###################################################################################################################



###################################################################################################################
							KEYWORDS IN C++
###################################################################################################################

1) STATIC: covered
2) AUTO: 
	* Self type deduction at the time of initialization. (initialization is must)
	* Increases compile time slightly but no effect on run time
3) EXTERN:
	* it is used to declare a variable which can be accessed across multiple files and headers.
	* multiple declaration of a extern variable is possible inside a same file
	* in case of no definition, compiler assumes that it will be defined somewhere, but linker will throw n error
	e.g.
		#include <iostream>
		extern int a;
		int main() {
			// Write C++ code here
			std::cout << "Try programiz.pro";
			std::cout<<std::endl<<a;
			return 0;
		}
		=======error========
		/rbin/ld: /tmp/ccgEile3.o: in function `main':
		AuUPDvUkpH.cpp:(.text+0x27): undefined reference to `a'
		ERROR!
		collect2: error: ld returned 1 exit status
4) MUTABLE:
	A const member function can not change any data member.
	mutable is a keyword that is used to allow const member function to modify it.
	So, if a data member is to be modified with const member function, it can only happen with mutable keyword
5) REGISTER:
	variables that are most likely to be accessed frequently can be made register type.
	making register type variable requests compiler to provide memory in register for this perticular variable.
	it compiler's choice to make it or not
	registers are faster than normal memory
	KEY POINTS:
	1) getting adddress of a register variable may lead to compilation error in c but will work fine in c++
	2) a pointer variable can be made as register type
	3) register can't be static and global (to be checked)
###################################################################################################################


###################################################################################################################
object slicing
###################################################################################################################
1) in case of inheritance, child class objects have properties of both base class and derived class but base class
	objects have their own properties only.
2) in case if we assign a derived class object to base class object, all the properties of derived class will be silced off
	this is called object slicing
3) another way when object slicing can happen is when we pass an object of derived class to a fuction that takes 
	object of base class as an argument
	
To avoid this slicing problems, we can use pointers and references


===============================================================
// Online C++ compiler to run C++ program online
#include <iostream>
class base
{
    public: 
    virtual void display()
    {
        std::cout<<"display function is called in base class"<<std::endl;
    }
    int a, b, c;
};


class derived : public base
{
    public:
        virtual void display()
        {
             std::cout<<"display function is called in derived class"<<std::endl;
        }
};


void somefunction(base obj)
{
    obj.display();
}
int main() {
    base b1;
    somefunction(b1);
    derived d1;
    somefunction(d1);
    return 0;
}
===============================================================
ISSUE
/tmp/vSNnPGJgnA.o
display function is called in base class
display function is called in base class
===============================================================




solution
using refernece
===============================================================
// Online C++ compiler to run C++ program online
#include <iostream>
class base
{
    public: 
    virtual void display()
    {
        std::cout<<"display function is called in base class"<<std::endl;
    }
    int a, b, c;
};


class derived : public base
{
    public:
        virtual void display()
        {
             std::cout<<"display function is called in derived class"<<std::endl;
        }
};


void somefunction(base& obj)
{
    obj.display();
}
int main() {
    base b1;
    somefunction(b1);
    derived d1;
    somefunction(d1);
    return 0;
}
===============================================================
display function is called in base class
display function is called in derived class

===============================================================

using pointers
===============================================================
// Online C++ compiler to run C++ program online
#include <iostream>
class base
{
    public: 
    virtual void display()
    {
        std::cout<<"display function is called in base class"<<std::endl;
    }
    int a, b, c;
};


class derived : public base
{
    public:
        virtual void display()
        {
             std::cout<<"display function is called in derived class"<<std::endl;
        }
};


void somefunction(base* obj)
{
    obj->display();
}
int main() {
    base* b1 = new base();
    somefunction(b1);
    derived* d1 = new derived();
    somefunction(d1);
    return 0;
}
===============================================================
/tmp/4ENUueuyvL.o
display function is called in base class
display function is called in derived class
===============================================================


###################################################################################################################
name mangling
###################################################################################################################
technique that compiler uses to dinstiguish between function with same name (function overlaoding)
example:
	int fx(int a, int b); -> will change to something like this int_fx_int_int
	int fx(flaot a, int b); -> will change to something like this int_fx_float_int
	
###################################################################################################################


###################################################################################################################
death of diamond problems
###################################################################################################################
Problem: in case when two super class of and inherited class share a common base class
		A
	   / \
	  B   C 
	   \ /
	    D
	in this case, if we create an object of class D, constructor of A will be called twice. Same case will be with the destructor.
	that means object of D will have two copies of wach data members of A.
Solution:
	1) using scope resolution operator to dinstiguish between members of class A.
	2) using virtual inheritance
	#include <iostream>

		class A {
			public:
			 int x = 5;
		};
		class B : virtual public A{
			public:
			  int i = 6;
		};
		class C : virtual public A{
			public:
			  int i = 7;
		};
		class D : public B, public C{
			
		};

		int main(){
			D obj;
			std::cout << obj.x << std::endl;

		}
###################################################################################################################

###################################################################################################################
file handeling in c++
###################################################################################################################
File stream classes:
	1) fstream:  for creating, reading and writing to a file
	2) ifstream: for reading info from file 
	3) ofstream: create and  write into file

ofstream:
	ofstream filestream("testout.txt"); //creating an object of ofstream class and assigning file name
	if (filestream.is_open()) {
		filestream << "Welcome to javaTpoint.\n";
		filestream.close();
	}
	
ifstream:
	ifstream filestream("testout.txt");  
	if (filestream.is_open()){
		while ( getline (filestream,srg) ){
			cout<<srg<<endl;
		}
		filestream.close();
	}

fstream:
	fstream fio;
	string line;
	fio.open("sample.txt", ios::trunc | ios::out | ios::in);
	while (fio) {
		getline(cin, line);
		if (line == "-1") break;
		fio << line << endl;
	
	}
	fio.close();


###################################################################################################################


###################################################################################################################
TIME COMPLEXITY NOTATIONS in c++
###################################################################################################################

1) Big O Notation (O):
	-> Big O notation describes the upper bound or worst-case scenario of an algorithm's time complexity. 
	-> It provides an asymptotic upper limit on the growth rate of the algorithm's running time.
	
2) Big Omega Notation (Ω):
	-> Big Omega notation describes the lower bound or best-case scenario of an algorithm's time complexity.
	-> It provides an asymptotic lower limit on the growth rate of the algorithm's running time.

3) Big Theta Notation (Θ):
	-> Big Theta notation describes the exact bound or average-case scenario of an algorithm's time complexity.
	-> It provides both an upper and lower limit on the growth rate of the algorithm's running time, 
		indicating that the time complexity is tightly bound within a constant factor of n.

###################################################################################################################

###################################################################################################################
SORTING ALGORITHMS AND THEIR TIME COMPLEXITY
###################################################################################################################



###################################################################################################################


###################################################################################################################
POINTER TO AN ARRAY AND POINTER ARITHMATICS
###################################################################################################################

	#include <iostream>
	using namespace std;
	int main() {
		int arr[5] = {1,2,3,4,5};
		
		//pointer arithmatic
		cout<<"arr is:"		<<arr<<endl; 	//arr is: 0x7ffe3f1dc2c0 	//decimal 140729957335744
		cout<<"arr+1 is:"	<<arr+1<<endl; 	//arr+1 is: 0x7ffe3f1dc2c4 	//decimal 140729957335748
		cout<<"&arr is:"	<<&arr<<endl; 	//&arr is: 0x7ffe3f1dc2c0 	//decimal 140729957335744
		cout<<"&arr+1 is:"	<<&arr+1<<endl;	//&arr+1 is: 0x7ffe3f1dc2d4 //decimal 140729957335764
	
		//pointer to an array
		int* ptr = arr;
		// *(ptr) = arr[0], *(ptr + 1)=arr[1]........
		int (*ptr1)[5];	//points to whole array 
		ptr1 = &arr;
		return 0;
	}
	
Applications of pointer to an array
	1) Passing Arrays to Functions:
	2) Dynamic Memory Allocation:
	3) Accessing Array Elements:

Pointer to a multidimensional array to be checked

Pointer arithmatic:
	1) Increment
	2) decrement
	3) comparision
	4) addition of constant
	5) substraction of constant
	6) comparision to NULL	
###################################################################################################################

###################################################################################################################
New for an array and multidimensional array
###################################################################################################################

	#include <iostream>
	using namespace std;

	int main() {
		//for an integer
		int* arr = new int;
		delete arr;
		
		//for array of integers
		int** arr1 = new int*[10];
		delete[] arr1;
		//for a string
		string* s = new string;
		delete s;
		
		//for array of strings
		string** s1 = new string*[10];
		for(int i=0; i<10; i++)
		{
			string* ptr = new string;
			*ptr = "bhaskar";
			s1[i] = ptr;
		}
		delete[] s1;
		
		//for array of array of string
		
		string*** s3 = new string**;
		delete s3;
		
		
		return 0;
	}

MEMORY ALLOCATION FOR A 2D ARRAY:
1) Single Allocation (Contiguous Memory):
	int main() {
		 int row = 3;
		 int column = 5;
		 int *arr = new int[row*column];
		 for(int i=0; i<row; i++)
		 {
			 for(int j=0; j<column; j++)
			 {
				 arr[row + column*j] = 1234;
			 }
		 }
		 delete[] arr;
	}

2) Double Allocation (Array of Pointers)
	int main() {
		 int** arr = new int*[10];
		 for(int i=0; i<10; i++)
		 {
			 int* row = new int[10]();//()initialise the array with 0
			 arr[i] = row;
		 }
		 for(int i=0; i<10; i++)
		 {
			 for(int j=0; j<10; j++)
			 {
				 std::cout<<arr[i][j]<<" ";
			 }
			 cout<<endl;
		 }
		 delete[] arr;
	}
	
MEMORY ALLOCATION FOR 3-D ARRAY

	int main() {
		 int*** arr = new int**[10];
		 for(int i=0; i<10; i++)
		 {
			 int** length = new int*[10];
			 for(int j=0; j<10; j++)
			 {
				 int* value = new int(10);
				 length[j] = value;
			 }
			 arr[i] = length;
		 }
	}

###################################################################################################################


###################################################################################################################
BIT WISE OPERATORS
###################################################################################################################

1) Bitwise AND (&)
2) Bitwise OR (|)
3) Bitwise XOR (^)
4) Bitwise NOT (~)
5) Left Shift (<<)
6) Right Shift (>>)
###################################################################################################################


###################################################################################################################
STRING, MEMBER FUNCTIONS AND CHARACTER ARRAY
###################################################################################################################

String:
	-> str.at(index) — Access character at index with bounds checking.
	-> str.capacity() — Returns the number of characters that can be held without 
	-> str.resize(new_size) — Changes the size of the string.
	-> str1.append(str2) — Appends str2 to str1.
	-> str1 < str2 — Compares str1 and str2 lexicographically.
	-> str.substr(pos, len) — Returns a substring starting at pos with length len.
	-> str.find(substring) — Finds the first occurrence of substring.
	-> str.rfind(substring) — Finds the last occurrence of substring.
	-> str.find_first_of(chars) — Finds the first occurrence of any character in chars.
	-> str.find_last_of(chars) — Finds the last occurrence of any character in chars.
	
	Manipulation:
	-> str.insert(pos, substring) — Inserts substring at pos.
	-> str.erase(pos, len) — Erases len characters starting at pos.
	-> str.replace(pos, len, substring) — Replaces len characters starting at pos with substring.
	
	Conversion:
	-> str.c_str() — Returns a C-style string (const char*).
	-> std::stoi(str) — Converts str to int.
	-> std::stod(str) — Converts str to double.
	-> std::to_string(value) — Converts value to a std::string.


Char array(#include <cstring>:
	-> strlen(arr)
	-> strcpy(destination, source) to copy one char array to another.
	-> strcat(arr1 + ar2)
	-> strcmp(arr1, arr2)	

###################################################################################################################




###################################################################################################################
						DESIGN PATTERN IN C++
###################################################################################################################

- Design pattern is bsically a solution for reoccuring problems while creating a software. It provides what pattern you can adopt for the  
software that you are designing. For example: if you are creating an logging software that writes logs, you can take the singelton 
approach where using single object can write the logs for you and there will not be any issue of multiple objects writing to the same 
file.

- Types of Design pattern:
  1) Creational Design Pattern: 
	a) They deal with process of creation of objects to make them mire efficient and flexible.

##########################################Singleton class#########################################################################

A Singleton is a design pattern that ensures a class has only one instance and provides a global point of access to that instance. This is particularly useful when exactly one object is needed to coordinate actions across the system, such as in logging, configuration management, or connection pooling.

Implementing a Singleton Class in C++
To implement a Singleton in C++, you typically follow these steps:

Private Constructor: The constructor is made private to prevent direct instantiation of the class from outside.
Static Instance: A static method that returns the single instance of the class.
Deleted Copy Constructor and Assignment Operator: To prevent copying of the Singleton instance.
Here's how you can implement a basic Singleton in C++:

cpp
Copy code
#include <iostream>

class Singleton {
private:
    // Private constructor to prevent instantiation
    Singleton() {
        std::cout << "Singleton instance created." << std::endl;
    }

    // Declare (but not define) copy constructor and assignment operator
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

public:
    // Static method to get the instance of the class
    static Singleton& getInstance() {
        static Singleton instance;  // Guaranteed to be destroyed and instantiated on first use
        return instance;
    }

    void showMessage() {
        std::cout << "Hello from Singleton!" << std::endl;
    }
};

int main() {
    // Access the Singleton instance
    Singleton& singleton = Singleton::getInstance();
    singleton.showMessage();  // Outputs: Hello from Singleton!

    return 0;
}
Key Points
Private Constructor: The constructor is private to ensure that no other object can create an instance of Singleton using the new keyword.

Static Instance Method: The getInstance() method returns the single instance of the class. It uses the local static variable instance, which ensures that the Singleton is created only once and destroyed when the program terminates.

Deleted Copy Constructor and Assignment Operator: The copy constructor and assignment operator are deleted to ensure that the Singleton cannot be copied or assigned, which would violate the Singleton property.

Thread Safety: The C++11 standard guarantees that the local static variable initialization is thread-safe, meaning the above Singleton implementation is safe for use in multithreaded environments.

#################################Multithreading#############################################################

syntax :  
	std::thread thread_object (callable);

std::thread is the thread class that represents a single thread in C++. To start a thread we simply need to create a new thread object and pass 
the executing code to be called (i.e, a callable object) into the constructor of the object. Once the object is created a new thread is launched 
which will execute the code specified in callable. 

A callable can be any of the five:
1. A Function Pointer
		void foo(param)
		{ 
		  Statements; 
		}
		// The parameters to the function are put after the comma
		std::thread thread_obj(foo, params);
		
2. A Lambda Expression

		// Define a lambda expression
		auto f = [](params)
		{
			Statements;
		};

		// Pass f and its parameters to thread
		// object constructor as
		std::thread thread_object(f, params);

3. A Function Object

		// Define the class of function object
		class fn_object_class {
			// Overload () operator
			void operator()(params)
			{ 
			  Statements; 
			}
		}
		// Create thread object
		std::thread thread_object(fn_object_class(), params)

4. Non-Static Member Function

		// defining clasc
		class Base {
		public:
			// non-static member function
			void foo(param) { Statements; }
		}

		// object of Base Class
		Base b;

		// first parameter is the reference to the functionn
		// and second paramter is reference of the object
		// at last we have arguments
		std::thread thread_obj(&Base::foo, &b, params);

5. Static Member Function

		// defining class
		class Base {
		public:
			// static member function
			static void foo(param) { Statements; }
		}

		// object of Base Class
		Base b;
		// first parameter is the reference to the function
		// and rest are arguments
		std::thread thread_obj(&Base::foo, params);

# Waiting for threads to finish
	Once a thread has started we may need to wait for the thread to finish before we can take some action. 
To wait for a thread, use the std::thread::join() function. This function makes the current thread wait until the thread 
identified by *this has finished executing.
For instance, to block the main thread until thread t1 has finished we would do:

		int main()
		{
			// Start thread t1
			std::thread t1(callable);

			// Wait for t1 to finish
			t1.join();

			// t1 has finished do other stuff
			Statements;
		}


A Complete C++ Program For Multithreading 
A C++ program is given below. It launches three threads from the main function. Each thread is called using one of the callable objects specified above.

// C++ program to demonstrate
// multithreading using three
// different callables.
#include <iostream>
#include <thread>
using namespace std;

// A dummy function
void foo(int Z)
{
    for (int i = 0; i < Z; i++) {
        cout << "Thread using function"
                " pointer as callable\n";
    }
}

// A callable object
class thread_obj {
public:
    void operator()(int x)
    {
        for (int i = 0; i < x; i++)
            cout << "Thread using function"
                    " object as callable\n";
    }
};

// class definition
class Base {
public:
    // non-static member function
    void foo()
    {
        cout << "Thread using non-static member function "
                "as callable"
             << endl;
    }
    // static member function
    static void foo1()
    {
        cout << "Thread using static member function as "
                "callable"
             << endl;
    }
};

// Driver code
int main()
{
    cout << "Threads 1 and 2 and 3 "
            "operating independently"
         << endl;

    // This thread is launched by using
    // function pointer as callable
    thread th1(foo, 3);

    // This thread is launched by using
    // function object as callable
    thread th2(thread_obj(), 3);

    // Define a Lambda Expression
    auto f = [](int x) {
        for (int i = 0; i < x; i++)
            cout << "Thread using lambda"
                    " expression as callable\n";
    };

    // This thread is launched by using
    // lambda expression as callable
    thread th3(f, 3);

    // object of Base Class
    Base b;
  
    thread th4(&Base::foo, &b);

    thread th5(&Base::foo1);

    // Wait for the threads to finish
    // Wait for thread t1 to finish
    th1.join();

    // Wait for thread t2 to finish
    th2.join();

    // Wait for thread t3 to finish
    th3.join();

    // Wait for thread t4 to finish
    th4.join();

    // Wait for thread t5 to finish
    th5.join();

    return 0;
}


########################Storage Class#################################
Specifier     	           Scope	        Lifetime	                                         Purpose
auto	                   Local	        Until block exits	                      Automatic storage (default for local vars)
register	               Local	        Until block exits	                     Hints to store in a CPU register
static	                   Local/Global	    Lifetime of the program	                Retains value between function calls
extern	                   Global	        Lifetime of the program	                 Refers to a variable/function defined elsewhere
mutable	                   Class Member	    Lifetime of the object	                Allows modification in const objects
thread_local	           Local/Global	    Lifetime of a thread	                Unique for each thread



##########################################################################
include guards with #ifdef / #endif (or #ifndef / #define / #endif)
##########################################################################
When you include header files in C++, sometimes the same header file may be included multiple times (directly or indirectly). This can cause redefinition errors (functions, variables, classes getting declared multiple times).

To avoid this, we use include guards with #ifdef / #endif (or #ifndef / #define / #endif).

Example:
// MyHeader.h
#ifndef MYHEADER_H   // check if not defined
#define MYHEADER_H   // define it

class MyClass {
public:
    void print();
};

#endif // MYHEADER_H


*How it works:
#ifndef checks if the macro (MYHEADER_H) is not defined yet.
If not defined, it defines it and includes the code inside.
Next time the header is included, MYHEADER_H is already defined → so compiler skips the whole header → prevents multiple definitions.

*Uses of #ifdef / #endif in header files:
Prevent multiple inclusions of the same header (classic use).
Conditional compilation – include certain code only if a macro is defined.

#ifdef DEBUG
#define LOG(x) std::cout << x << std::endl
#else
#define LOG(x)
#endif


→ Useful for enabling/disabling debugging or platform-specific code.
Cross-platform code – e.g., different headers for Windows vs Linux.

#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif








########################################################################################################################################################################
STRING, MEMBER FUNCTIONS AND CHARACTER ARRAY
########################################################################################################################################################################

String:
	-> str.at(index) — Access character at index with bounds checking.
	-> str.capacity() — Returns the number of characters that can be held without 
	-> str.resize(new_size) — Changes the size of the string.
	-> str1.append(str2) — Appends str2 to str1.
	-> str1 < str2 — Compares str1 and str2 lexicographically.
	-> str.substr(pos, len) — Returns a substring starting at pos with length len.
	-> str.find(substring) — Finds the first occurrence of substring.
	-> str.rfind(substring) — Finds the last occurrence of substring.
	-> str.find_first_of(chars) — Finds the first occurrence of any character in chars.
	-> str.find_last_of(chars) — Finds the last occurrence of any character in chars.
	
	Manipulation:
	-> str.insert(pos, substring) — Inserts substring at pos.
	-> str.erase(pos, len) — Erases len characters starting at pos.
	-> str.replace(pos, len, substring) — Replaces len characters starting at pos with substring.
	
	Conversion:
	-> str.c_str() — Returns a C-style string (const char*).
	-> std::stoi(str) — Converts str to int.
	-> std::stod(str) — Converts str to double.
	-> std::to_string(value) — Converts value to a std::string.


Char array(#include <cstring>):
	-> strlen(arr)
	-> strcpy(destination, source) to copy one char array to another.
	-> strcat(arr1 + ar2)
	-> strcmp(arr1, arr2)	

########################################################################################################################################################################

########################################################################################################################################################################
EXCEPTION HANDELING
########################################################################################################################################################################

-> exceptions are abnormal conditions a program encounters during execution.
-> types
	1) Synchronous: happens in case of unexpected input or input data type such as dividing by zero.
	2) Asynchronous: happens due to disc failure or keyboard interrupts.

-> method to handle exceptions:
	try -> a block of code that may throw exception 
	catch -> block of code that will be executed in case of exception (there can be many catch block for a single try block)
	throw -> (optional) once program hits throw block it terminates the current fucntion and starts searching for catch block.


	
-> Properties:
	a) catch all (catch(...))
	b) no implicit type conversion:
		int main()
		{
			// try block
			try {
		 
				// throw
				throw 10;
			}
		 
			// catch block
			catch (char* excp) {
				cout << "Caught " << excp;
			}
		 
			// catch all
			catch (...) {
				cout << "Default Exception\n";
			}
			return 0;
		}
		/// default one will be called
	
	c) if exception is thrown and is not caught anywhere, program will terminate.
	d) there can be nested try catch
	e) in case of exception, all the objects created inside try block will be destroyed before program reaches to catch block.

########################################################################################################################################################################

Pure VIRTUAL function
	A do nothing virtual function is called pure virtual function.
	syntax : 
		virtual void fun() = 0;
	Compiler doesnt allow to call this function as it is useless, to avoid its calling there are certain rules
	1. This function can be called via class object, thats why cpp doesnt allow to make a object of class having pure virtual function.
	2. This can be called via child class object, to avoid this it is compulsory to override do nothing function. 
	3. This can be called via pointer of base class which is pointing address of child class object. to avoid this it is mandatory to 
		make do nothing function as virtual.
	
A class having atleast one do thing function is called abstract class for which we can not make object and it is only used as 
parent class.

##########################################################################################################################################

Diff bw copy constructor and copy assignment operator

class student
{
	public:
};
int main()
{
	student s1;
	student s2 = s1; // this is done by copy constructor 
	student s3;
	s3 = s1;  // this is done by copy assignment operator made by compiler in class
}


####################################################################################################################################

TEMPLATE AND STATIC VARIABLE 

The basic and important thing here is in case of template function or class, compiler made different function or class for each data type.

template<typename T>
T fun(T a, T b)     | int fun(int a, int b)   |   float fun(float a, float b) 
{                   | {                       |   {
	return a + b;   |		return a + b;     |			return a + b;         and so on same for class.
}                   | }                       |   }

Now suppose any template class is holding data member that is static 

template <class T> class Test
{  
private:
  T val; 
public:
  static int count;
  Test()
  {
    count++;
  }
  // some other stuff in class
};

template<class T>
int Test<T>::count = 0;

int main()
{
  Test<int> a;  // value of count for Test<int> is 1 now
  Test<int> b;  // value of count for Test<int> is 2 now
  Test<double> c;  // value of count for Test<double> is 1 now   
  cout << Test<int>::count   << endl;  // prints 2  
  cout << Test<double>::count << endl; //prints 1
   
  return 0;
}

Note - Different data type means different class as compiler will make for each data type, and all static member will be different
		for each data type but same for different object of same data type. Same thing applies for function also.
		
		
##########################################################################################################################################

printf will return the number of character it is printed. 

printf("%d", printf("%d\n", 123)); 

O/P 
123
3
second printf has returned the value of character it has printed that is 3 here.

######################################################################################################################################

scanf will return total no of values it has read from the console 

int a, b;
printf("%d", scanf("%d%d, &a, &b));

O/P 
2 // scnaf will read 2 data and return same value



#######################################################################################################################################

we can use __LINE__ to print current line number and __FUNCTION__ to print current function

#######################################################################################################################################

Initialising extern variable in function is not allowed but can be done gloabally.

extern int c = 10;    // It will work fine

void fun()
{
	extern int a = 10; // It will give error.
}

#######################################################################################################################################

If we assign multiple character to a char variable then it will take only the last char.

char ch = 'abc';  // It will take 'c' only in ch;

########################################################################################################################################

If we intialise any structure with values less than the varibale contained inside the structure then it will assign values from start 
and others values will get 0.

struct temp{int a, b, c};

temp t = {10};  // It will assign 10 to a and for b, c will get 0.

#######################################################################################################################################

Modulus operator(%) will give compilation error on float numbers and to work properly we can use fmod(T val, T mod) function.

#######################################################################################################################################

To find the size of an array we can use the sizeof operator and it will give me the size of that array but we can only do this in same
function in which array is declared/defined, in another function it is always passed by its base address.

Array and pointer are 2 different things and internally also array(arr) is not a purely pointer variable but it can decay into pointer 
of its first element (&arr[0]) but not always, sizeof doesnot decay array to pointer but explicit coveration or function passing will do.

void fun(int arr[])   // this is same as int* arr
{
    cout << sizeof(arr)/sizeof(arr[0]) << endl;    // It will print 2(8 -> sizeof adress variable and 4 -> sizeof int)
    for(int i = 0; i < 5; i++)
        cout << arr[i] << endl;
}

int main() {
	// your code goes here
    int arr[] = {1, 2, 3, 4, 5};
    cout << sizeof(arr)/sizeof(arr[0]) << endl;  // It will print 5(20 -> sizeof whole array and 4 -> sizeof int)
    fun(arr);
    return 0;
}

Also if we try to print arr and &arr, it will give same output but meanings are different as arr will be decayed to pointer and holds
the address of arr[0] but &arr will hold address of the whole array that is same as the first byte address.
This we can visualise if we try to get address by +1.

arr + 1 -> it will give address of arr[1] (arr + sizeof(arr[0]))
&arr + 1 -> it will give next byte address after the whole array basically (arr + sizeof(arr))

#######################################################################################################################################

While passing multidimentional array to function, we have to give all the dimensions expect the first one and it is considered as pointer
of arr[0] but arr[0] is not a pointer type it is an array variable and thats why will give its true size.

void fun(int (*arr)[5])  // it is same as arr[][5]
{
    cout << sizeof(arr) << ", " << sizeof(arr[0]) << endl;   // It will print 8 and 20 as arr is pointer variable but arr[0] is an 
															//array varibale
    for(int i = 0; i < 5; i++)
        for(int j = 0; j < 2; j++)
            cout << arr[i][j] << endl;
}

int main() {
	// your code goes here
    int arr[][5] = {{1, 2}, {3, 4}, {5, 6}, {7, 8}, {9, 10}};
    cout << sizeof(arr) << ", " << sizeof(arr[0]) << endl;     // It will print 100(5 * 20) and 20, as here, arr and arr[0] both are
																// array variable not pointers.
    fun(arr);
    return 0;
}

#########################################################################################################################################

How to return 2-D array from a function?

If we make any static 2-D array, and returning it then it will give segmentation fault as any memory allocated in function will go out 
of scope if that function finishes its work.

Now returning 2-D array can be done in 3 ways
1. Using Dynamic allocation -> this will make the whole array in heap section and thatswhy can be accessed.

int N = 3;
int** getArray()
{
    int** arr = new int*[N];
    for (int i = 0; i < N; ++i) {
        arr[i] = new int[N];
        for (int j = 0; j < N; ++j) {
            arr[i][j] = i + j;
        }
    }
    return arr;
}

int main()
{
    int** arr;
    arr = getArray();
    printArray(arr);
    return 0;
}

2. Using static keyword -> this will make the whole array into initialised data section and can be accessed. 

int (*(getArray)())[N]
{
    static int arr[N][N]
        = { { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 } };
    return arr;
}

int main()
{
    int(*arr)[N];
    arr = getArray();
    printArray(arr);
    return 0;
}

3. Using structure -> this looks like returning value and it will return a whole copy.

struct ArrStruct {
    int arr[N][N];
};

ArrStruct getArray()
{
    ArrStruct var;
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            var.arr[i][j] = i + j;
        }
    }
    return var;
}

int main()
{
    ArrStruct arr;
    arr = getArray();
    printArray(arr);
    return 0;
}

#####################################################################################################################################

Malloc is always faster than calloc and malloc will return the void pointer returned by kernel after allocating the memory but 
Calloc will intialise everything with 0 after it gets memory from kernel and then return the void pointer of first element.

This initialisation is taking little extra time but if i have initialise everything with 0 then it shoule be better to use calloc
instead of malloc and memset function to initialise as calloc does some optimasation and make it faster overall.

#####################################################################################################################################

How we can stop someone taking the adddress of our class object?

If we assign adress of any class object to class type pointer then internally it will call '&' function that is made my compiler 
implictly. To not take address basically we want to not call this function and this can be done via 
1. make the & function private

class MyClass {
    // This will cause a compilation error if anyone tries to use `&myObject`.
    MyClass* operator&();
};

int main() {
    MyClass myObject;
    // MyClass* ptr = &myObject; // ERROR: call to private member function 'operator&'
    return 0;
}

2. Delete & function

class MyClass {
public:
    // This will cause a compilation error if anyone tries to use `&myObject`.
    MyClass* operator&() = delete;
};

int main() {
    MyClass myObject;
    // MyClass* ptr = &myObject; // ERROR: call to deleted member function 'operator&'
    return 0;
}


#######################################################################################################################################

LITTLE ENDIAN VS BIG ENDIAN

Little endian store any data in ram from least significant byte to most significant byte but big endian will store opposite(from 
most significant byte to least significant byte).

For example
int *ptr = 0X01234567;

In Big Indian it is stored as -> |01|23|45|67| 
In Litte Indian it is stored as -> |67|45|23|01|

How to find any system is big endian or little endian

#include <bits/stdc++.h>
using namespace std;

int main() {
	// your code goes here
    unsigned int a = 1;
    char *c = (char *)&a;
    if(*c)
        cout << "Little Endian";
    else
        cout << "Big Endian";
    return 0;
}

########################################################################################################################################

We can use pointer and refernce both instead of direct variable in some cases 
1. Pass big object to function.
2. To avoid object slicing.
3. To modify local variable of caller function
4. To acheive runtime polymorphism.

Sometime we should use only reference not pointer
1. copy constructor

Sometime we should only use pointer not reference
1. Data structure like linked list, trees, graphs as we need to assign NULL in some node to denote something.
2. Chnage pointer to point another node. (reference varible can not refernce another varible)

#######################################################################################################################################

How to call some function before main()? 

we can make any global object of a class which is calling some functiop in its constructor.

#include <bits/stdc++.h>
using namespace std;

int fun()
{
    cout << "Inside fun" << endl;
    return 1;
}
class abc
{
    public:
        abc()
        {
            fun();
        }
} d;
int e = fun();
int main() {
	// your code goes here
    cout << "Inside main" << endl;
}

Same we can do by making one static variable in class and then while defining we can call that function.

#########################################################################################################################################

Constructor Delegation

We can call another type of constructor from one constructor (from initialiser list) to avoid duplicacy.

#include <bits/stdc++.h>
using namespace std;

class abc
{
    int a, b;
public:
    abc(): abc(0, 0){}
    abc(int x) : abc(x, 0){}
    abc(int x, int y) : a{x}, b{y} {
        //some very big and complex code to intialse the value of a and b
        //If we not call this from other constructor then we have to use this big and complex code in all the constructor 
		//which is nothing but code duplicacy.
    }
    void print()
    {
        cout << "a : " << a << " b : " << b << endl;
    }
};

int main() {
	// your code goes here
	abc ob1;
	abc ob2(10);
	abc ob3(10, 10);
	
	ob1.print();
	ob2.print();
	ob3.print();

}

#######################################################################################################################################

How comma operator works?

It works from left to right.

#include <bits/stdc++.h>
using namespace std;

int main() {
	// your code goes here
	int b = (1, 2, 3);
	
	cout << b << endl;  // print 3 (from left to right)

}

#######################################################################################################################################

How to stop copy of an object ? 

1. By making copy constructor and copy assignment operator private.
2. By Deleting copy constructor and copy assignment operator.
3. By inheriting from a class whose copy constructor and copy assignment operator is private.
	When you copy-construct a derived class, the base part must also be copy-constructed.
	When you assign a derived class, the base part must also be assigned.

########################################################################################################################################

Code Bloating

code bloating is the production of code that is percieved as unnecessary long, slow or wastage of resource.

int main()
{
	string s1("www");
	string s2("google");
	string s3("com");
	
	string googleAdress = s1 + s2 + "." + s3;
	cout << googleAdress << endl;
}

this is the example of code bloating as we are making 3 unnecessary string instead we can do this 

int main()
{
	cout << "www.google.com" << endl;
}

####################################################################################################################################

How to convert any class into some int(primitive data type)

This can be done using oparator overloading

#include <bits/stdc++.h>
using namespace std;

class abc
{
        int data;
    public:
        abc(int val)
        {
            data = val;
        }
        operator int ()
        {
            return data;
        }
};

int main() {
	// your code goes here
	abc d(10);
	int val = d;
	cout << val << endl;
	return 0;
}

To provide better readablity and force user to use static_cast we can use explicit keyword

#include <iostream>

class MyClass {
public:
    int value;

    MyClass(int v) : value(v) {}

    // Explicit conversion operator to int
    explicit operator int() const {
        return value;
    }
};

int main() {
    MyClass obj(20);
    // int i = obj; // This would cause a compilation error with 'explicit'
    int i = static_cast<int>(obj); // Explicit conversion required
    std::cout << "Explicitly converted int: " << i << std::endl; // Output: 20
    return 0;
}


How to convert a int to class ?
This can be done using constructor and to use static cast we can make constructor explicit.

########################################################################################################################################

FOR_EACH

for_each(arr.begin(), arr.end(), lambda function/function to be executed at each iteration) is used when we have to run a loop over 
some intervals.

#########################################################################################################################################

Why return type of copy assignment operator should always be class object reference.

To support chaining assignment.


#include <bits/stdc++.h>
using namespace std;

class abc
{
    public:
        int data;
        abc(){}
        abc(int val) : data{val} {}
        abc& operator = (abc& ob)
        {
            data = ob.data;
            return *this;
        }
        void print()
        {
            cout << data << endl;
        }
};

int main() {
	// your code goes here
    abc ob1(10);
    abc ob2, ob3, ob4;
    ob4 = ob3 = ob2 = ob1;  // this chaining assignment is not possible if return type of copy assignment operator is void or 
							//some primitive type.
    (ob3 = ob2) = ob1;    //this case will not give correct/expected output if return type of copy assignment operator is only 
							//simple object but not object reference. If simple object is the return type instead of reference object
							//ob2 will be copied to ob3 only but here expected is first ob2 copied in ob3 and then ob1 is copied in ob3.
    ob1.print(); ob1.print(); ob3.print(); ob4.print();
    return 0;
}

########################################################################################################################################

How to identify if 2 object belongs to same class or not ?

By using "typeid()" function which basically tells the type of any object.

#include <iostream>
#include<typeinfo> // this containes typeid function
using namespace std;

class A{};
class B{};

int main() {
	// your code goes here
    A a1, a2;
    B b1, b2;
    if(typeid(a1) == typeid(a2))     // we can not print these typeid as << operator is deleted and we can not use cout. 
        cout << "Belongs to same class" << endl;
    else
        cout << "Belongs to different class" << endl;
    if(typeid(a1) == typeid(b2)) 
        cout << "Belongs to same class" << endl;
    else
        cout << "Belongs to different class" << endl;
    return 0;
}

######################################################################################################################################

How to restrict any class to be inherited?

By using "final" keyword, if any class is declared final then that class will not be inherited.

#include <bits/stdc++.h>
using namespace std;

class Base final
{
    public:
        Base(){}
};
class Derived : public Base
{
    public:
        Derived(){}
};

int main() {
	// your code goes here
    Derived d;
}

O/P -> This program will give compilation error as final class can not be inherited.

#######################################################################################################################################

OVERRIDE keyword

This is basically used on that function that is overriding in derived class to increase the readablity purpose as well as testing purpose
if Base class is in other file we dont have to go there we now if override is there this function must be in the base class.

By writing this we ensure that if any function should be overrided then we can write this keyowrd and if same function is not in base 
class with virtual keyword then will give compilation error.

#include <bits/stdc++.h>
using namespace std;

class Base
{
    public:
        virtual void fun(){}
};
class Derived : public Base
{
    public:
        void fun(int x) override{}  // If override is not there then it will compile but currently it will give compilation error.
};

int main() {
	// your code goes here
    Derived d;
}

########################################################################################################################################

Why using namespace std is bad ?

In big program/project where there are so much libraries and there can be collision of the name for example if any library have something
as cout then it will cause consfusion that's why it is good to not include "using namespace std" in program and if we have to use any
library then we can use by "std::some_library".

########################################################################################################################################

Why template should be only defined in header files?

Unlike normal function which can be declared in header files and can be difined in cpp file and can be used in other cpp file we can't
do this in case of template function as compiler will make multiple function out of template function at the definition only and if 
definition is not there in header file then used cpp file can have undefined reference error. We can resolve this by either defining in
header file or we can include cpp file that has the required definition. 

########################################################################################################################################

How to print something N no of times without using loop or recursion.

We can use constructor for it.
#include <bits/stdc++.h>
using namespace std;

class abc
{
    public:
        abc(){cout << "inside constructor" << endl;}
};

int main() {
    int n = 10;
	abc ob[n];
	return 0;
}

########################################################################################################################################

Pre increment operator is faster than the post increment operator as pre increment is taking only 3 assembly instruction while 
post increment will take 4.

########################################################################################################################################

Static data member will not occupy space inside the class memory, they are just like the global variable with just have the wrapper of the 
class to use this static data member with class name and scope resolution operator.

#include <bits/stdc++.h>
using namespace std;

class A{
    public:
        int a;
        static int b;
};
int A::b = 10;
int main() {
	// your code goes here
    cout << sizeof(A) << endl;   // It will print 4 for memory of a not 8.
}

########################################################################################################################################

Alternate operator are just an alias of operator provided in c++, we can use "and" instead of "&&" or we can use "or" instead of "||".

########################################################################################################################################

THIS POINTER

1. It is passed implictly to all non static member function of the class, static member function doesnt have this pointer.
2. It is a const pointer that is holding the address of caller object.
3. If any non static member function is defined/declared as const then this pointer will become const pointer to const type.

abc ob;
ob.fun(10); // this is converted into ob.fun(&ob, 10);

########################################################################################################################################

FUNCTION HIDING

When we have a function with same name in base and derived class both with no virtual keyword then for derived class object/pointer 
base class functions are not accessible (that has the same name in derived).
If we want to get access of the base class functions then we can do this in 2 ways 
1. using scope resolution operator (ob.Base::fun(100))
2. writing "using Base::fun;" in derived class.

#include <bits/stdc++.h>
using namespace std;

class Base
{
    public:
        void fun(int a)
        {
            cout << "Base class function" << endl;
        }
};

class Derived : public Base
{
    public:
        void fun(char ch)
        {
            cout << "Derived class function" << endl;
        }
};

int main() {
    Derived ob;
    ob.fun(500);  // it will print "Derived class function"
    ob.fun('a');  // it will print "Derived class function"
    return 0;
}

#########################################################################################################################################

PLACEMENT NEW

Base *p = new Base;
By this statement we are requesting kernel to allocate some memory and return its address.

if suppose we have to make multiple (10 or 100) object dynamically using new keyword then we have to switch user mode to krnel mode 
again and again which is a time consuming process, so instead of that what we can do is we can make a storage of that many object.

char* memory = new char[10 * sizeof(Base)];  // this is beasically memory pool we created

Base *ob1 = new (&memory[0]) Base;                    //we are providing memory also so that ob1 will be created on that memory only
Base *ob1 = new (&(memory[0] + sizeof(Base))) Base;   //we dont have to switch to kernel mode then as allocation is already there.
Base *ob1 = new (&(memory[0] + 2 * sizeof(Base))) Base;

ob1 -> ~Base();              //Calling Destructor is mendatory here as if char* memory will go out of scope, it will not call destructor.
ob2 -> ~Base();
ob3 -> ~Base();

#########################################################################################################################################

lvalue VS ravlue and lvalue refernce VS rvalue refernce

what is lvalue and rvalue?
“l-value” refers to a memory location that identifies an object. 
"r-value” refers to the data value that is stored at some address in memory

what is lvalue and rvalue reference?

Lvalue reference (T&)
Binds to an lvalue (something with a name/address).
Example:
int x = 10;
int& ref = x;  // okay
// int& ref2 = 5; // error: cannot bind non-const lvalue reference to rvalue

Rvalue reference (T&&)
Can bind to rvalues only.
Allows us to “take ownership” of temporaries → move semantics.
Example:
int&& rref = 5;   // okay
// int&& rref2 = x; // error: x is an lvalue

Const lvalue reference (const T&)
Special rule: can bind to rvalues as well.
Compiler extends lifetime of the temporary.
Example:
const int& ref = 5; // okay, temporary "5" extended

#######################################################################################################################################

MOVE SEMANTICS

Move is basically used to move the ownerwship of one object to another, this is different from copy as we can not use previous object
if its ownership is moved to another object. To acheive this we can implement move constructor and move assignment operator and can call
them using "std::move(object)" which basically convert any lvalue object to rvalue. 

#include <bits/stdc++.h>
using namespace std;

class simple
{
public:
    int *p;
    simple(int data):p(new int(data))
    {
        cout << "constructor called with data : " << (*p)<<endl;
    }
    simple(const simple& other)
    {
        p = new int(*(other.p));
        cout << "copy constructor called with data : " << (*p)<<endl;
    }
    simple(simple&& other) noexcept
    {
        p = other.p;
        other.p = NULL;
        cout << "move constructor called with data : " << (*p)<<endl;
    }
    simple& operator =(simple&& other) noexcept
    {
        if(this != &other)
        {
            p = other.p;
            other.p = NULL;
        }
        cout << "move assignment operator called with data : " << (*p) <<  endl;
        return *this;
    }
    ~simple()
    {
        cout << "destructor called";
        if(p)
        {
            cout << " with data : " << (*p);
            delete p; // this check is required as we are assigning NULL in move constructor and without check delete will cause crash.
        }
        cout << endl;
        p = NULL;
    }
};

int main() {
	vector<simple> arr;
	arr.reserve(2);
	simple ob1(10);
	simple ob2 = std::move(ob1);
    arr.push_back(ob2);
	simple ob3(simple(20));
	simple ob4(simple(30));
	ob4 = std::move(ob3);
	arr.push_back(ob4);
	cout << "Resizing" << endl;
    arr.push_back(simple(40));
    return 0;
}

O/P - 
constructor called with data : 10                 //this is printed due to "simple ob1(10);"

move constructor called with data : 10            //this is printed due to "simple ob2 = std::move(ob1);"

copy constructor called with data : 10            //this is printed due to "arr.push_back(ob2);", 
												  //ob2 is copied to array index using copy constructor
												  
constructor called with data : 20                 //this is printed due to "simple ob3(simple(20));" it is basically constructor 
												  //and move constructor but compiler will do some modification to only call 
												  //constructor to reduce effort and attain same thing.
												  
constructor called with data : 30                 //this is printed due to "simple ob4(simple(30));"

move assignment operator called with data : 20    //this is printed due to "ob4 = std::move(ob3);"

copy constructor called with data : 20            //this is printed due to arr.push_back(ob4);
Resizing
constructor called with data : 40                 //this is printed due to "simple(40)" and create temp object

move constructor called with data : 40            //this is printed due to "arr.push_back(simple(40));" as temp object is rvalue

move constructor called with data : 10            //this is due to increase the size and data is moving into other array, 
											      //this called move constructor as noexcept is there which tells compiler that move
												  //constructor has no exception otherwise compiler will call for copy constructor.
												  
destructor called                                 //destructor called for temp object of "simple(40)"

move constructor called with data : 20            //this is due to increase the size and data is moving into other array,

destructor called                                 //this is for object that is in old array
destructor called                                 //this is for object that is in old array
destructor called with data : 20                  //this is for object ob4
destructor called                                 //this is for object ob1 which gave ownership to ob2
destructor called with data : 10                  //this is for object ob2
destructor called                                 //this is for object ob3
destructor called with data : 10                  //this is for arr[0]
destructor called with data : 20                  //this is for arr[1]
destructor called with data : 40                  //this is for arr[2]

########################################################################################################################################

#include <iostream>
#include <vector>
using namespace std;

class Demo {
public:
    vector<int> v;
    Demo() { cout << "Default\n"; }
    Demo(const Demo& d) { v = d.v; cout << "Copy Ctor\n"; }
    Demo(Demo&& d) noexcept { v = move(d.v); cout << "Move Ctor\n"; }
    Demo& operator=(const Demo& d) { v = d.v; cout << "Copy Assign\n"; return *this; }
    Demo& operator=(Demo&& d) noexcept { v = move(d.v); cout << "Move Assign\n"; return *this; }
};

Demo getDemo() {
    Demo d;
    return d;
}

int main() {
    Demo a;
    Demo b = a;          // Copy constructor
    Demo c = getDemo();  // Move constructor
    b = a;               // Copy assignment
    c = getDemo();       // Move assignment
}


#example 2

#include <iostream>
#include <cstring>

class String {
    char* data;

public:
    // 1️⃣ Constructor
    String(const char* s = "") {
        data = new char[strlen(s) + 1];
        strcpy(data, s);
        std::cout << "Constructed: " << data << "\n";
    }

    // 2️⃣ Copy Constructor
    String(const String& other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
        std::cout << "Copied: " << data << "\n";
    }

    // 3️⃣ Move Constructor
    String(String&& other) noexcept {
        data = other.data;
        other.data = nullptr;
        std::cout << "Moved!\n";
    }

    // 4️⃣ Copy Assignment
    String& operator=(const String& other) {
        if (this != &other) {
            delete[] data;
            data = new char[strlen(other.data) + 1];
            strcpy(data, other.data);
        }
        std::cout << "Copy Assigned: " << data << "\n";
        return *this;
    }

    // 5️⃣ Move Assignment
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        std::cout << "Move Assigned!\n";
        return *this;
    }

    // Destructor
    ~String() {
        if (data)
            std::cout << "Destroyed: " << data << "\n";
        delete[] data;
    }
};

int main() {
    String s1("Hello");                // Constructor
    String s2 = s1;                    // Copy Constructor
    String s3 = String("World");       // Move Constructor (temporary rvalue)
    s2 = s3;                            // Copy Assignment
    s3 = String("C++");                // Move Assignment (temporary rvalue)
    return 0;                           // Destructors called for s1, s2, s3
}
Step-by-Step Explanation
Line	Code	Function Called	Why
1	String s1("Hello");	Constructor	Creating s1 from a C-string literal
2	String s2 = s1;	Copy Constructor	s2 is new object, s1 is lvalue
3	String s3 = String("World");	Move Constructor	Right-hand side is temporary rvalue (String("World"))
4	s2 = s3;	Copy Assignment	s2 exists already, s3 is lvalue → deep copy
5	s3 = String("C++");	Move Assignment	RHS is temporary rvalue → ownership transferred
6	return 0;	Destructor	Objects destroyed in reverse order of creation: s3, s2, s1

Expected Console Output
yaml
Copy code
Constructed: Hello
Copied: Hello
Constructed: World
Moved!
Copy Assigned: World
Constructed: C++
Move Assigned!
Destroyed: C++
Destroyed: World
Destroyed: Hello
